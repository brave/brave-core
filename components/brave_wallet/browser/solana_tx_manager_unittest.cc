/* Copyright (c) 2022 The Brave Authors. All rights reserved.
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at https://mozilla.org/MPL/2.0/. */

#include "brave/components/brave_wallet/browser/solana_tx_manager.h"

#include <map>
#include <memory>
#include <optional>
#include <string_view>
#include <utility>

#include "base/base64.h"
#include "base/files/scoped_temp_dir.h"
#include "base/location.h"
#include "base/run_loop.h"
#include "base/scoped_observation.h"
#include "base/task/sequenced_task_runner.h"
#include "base/test/bind.h"
#include "base/test/task_environment.h"
#include "base/test/values_test_util.h"
#include "brave/components/brave_wallet/browser/blockchain_registry.h"
#include "brave/components/brave_wallet/browser/brave_wallet_constants.h"
#include "brave/components/brave_wallet/browser/brave_wallet_prefs.h"
#include "brave/components/brave_wallet/browser/brave_wallet_utils.h"
#include "brave/components/brave_wallet/browser/json_rpc_service.h"
#include "brave/components/brave_wallet/browser/keyring_service.h"
#include "brave/components/brave_wallet/browser/network_manager.h"
#include "brave/components/brave_wallet/browser/solana_block_tracker.h"
#include "brave/components/brave_wallet/browser/solana_instruction_data_decoder.h"
#include "brave/components/brave_wallet/browser/solana_keyring.h"
#include "brave/components/brave_wallet/browser/solana_test_utils.h"
#include "brave/components/brave_wallet/browser/solana_transaction.h"
#include "brave/components/brave_wallet/browser/solana_tx_meta.h"
#include "brave/components/brave_wallet/browser/solana_tx_state_manager.h"
#include "brave/components/brave_wallet/browser/test_utils.h"
#include "brave/components/brave_wallet/browser/tx_service.h"
#include "brave/components/brave_wallet/common/brave_wallet.mojom.h"
#include "brave/components/brave_wallet/common/brave_wallet_constants.h"
#include "brave/components/brave_wallet/common/brave_wallet_types.h"
#include "brave/components/brave_wallet/common/encoding_utils.h"
#include "brave/components/brave_wallet/common/solana_utils.h"
#include "components/grit/brave_components_strings.h"
#include "components/sync_preferences/testing_pref_service_syncable.h"
#include "services/data_decoder/public/cpp/test_support/in_process_data_decoder.h"
#include "services/network/public/cpp/weak_wrapper_shared_url_loader_factory.h"
#include "services/network/test/test_url_loader_factory.h"
#include "testing/gmock/include/gmock/gmock.h"
#include "testing/gtest/include/gtest/gtest.h"
#include "ui/base/l10n/l10n_util.h"
#include "url/origin.h"

namespace {

constexpr char kEncodedSerializedMessage[] =
    "FDmjJVJ5XUQPik2xqs7NqP7VdMkDXNWLimqTR8C2KstRHZAdRUoCMQr7LXUjQ6dSer9jfWWfbN"
    "XzMToAWzoQLWvgduNCLxSVWVuiVZzqGPwC8mWT4SAu5NDCC5VTWcSNWj4Q9HSvgQitodttQiQR"
    "3yQvRZJurNzub3SBK3umEqULkVJPYZJRCmPbXQm9ebPEXGYQRKrjiAt7";

constexpr char kMockGetFeeForMessageResponse[] = R"({
      "jsonrpc":"2.0","id":1,
      "result": {
        "context":{"slot":123065869},
        "value": 5000
      }
    })";

constexpr char kMockMerkleTreeAccountInfo[] =
    R"(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)";

}  // namespace

namespace brave_wallet {

class MockTxStateManagerObserver : public TxStateManager::Observer {
 public:
  explicit MockTxStateManagerObserver(TxStateManager* tx_state_manager) {
    observation_.Observe(tx_state_manager);
  }

  MOCK_METHOD1(OnTransactionStatusChanged, void(mojom::TransactionInfoPtr));
  MOCK_METHOD1(OnNewUnapprovedTx, void(mojom::TransactionInfoPtr));

 private:
  base::ScopedObservation<TxStateManager, TxStateManager::Observer>
      observation_{this};
};

class SolanaTxManagerUnitTest : public testing::Test {
 public:
  SolanaTxManagerUnitTest()
      : task_environment_(base::test::TaskEnvironment::TimeSource::MOCK_TIME),
        shared_url_loader_factory_(
            base::MakeRefCounted<network::WeakWrapperSharedURLLoaderFactory>(
                &url_loader_factory_)) {}

  void SetUp() override {
    tx_hash1_ =
        "5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpR"
        "zrFmBV6UjKdiSZkQUW";
    tx_hash2_ =
        "5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJin"
        "ENTkpA52YStRW5Dia7";
    latest_blockhash1_ = "EkSnNWid2cvwEVnVx9aBqawnmiCNiDgp3gUdkDPTKN1N";
    latest_blockhash2_ = "FkSnNWid2cvwEVnVx9aBqawnmiCNiDgp3gUdkDPTKN1N";
    latest_blockhash3_ = "GkSnNWid2cvwEVnVx9aBqawnmiCNiDgp3gUdkDPTKN1N";
    last_valid_block_height1_ = 3090;
    last_valid_block_height2_ = 3290;
    last_valid_block_height3_ = 3490;
    fee_estimation1_ = mojom::SolanaFeeEstimation::New();
    fee_estimation1_->base_fee = 5000;
    fee_estimation1_->compute_units = 76249U;  // ceil(1.10 * (69017 + 300))
    fee_estimation1_->fee_per_compute_unit = 100;

    SetInterceptor(latest_blockhash1_, last_valid_block_height1_, tx_hash1_, "",
                   false, last_valid_block_height1_);
    brave_wallet::RegisterProfilePrefs(prefs_.registry());
    brave_wallet::RegisterLocalStatePrefs(local_state_.registry());
    brave_wallet::RegisterProfilePrefsForMigration(prefs_.registry());
    network_manager_ = std::make_unique<NetworkManager>(&prefs_);
    json_rpc_service_ = std::make_unique<JsonRpcService>(
        shared_url_loader_factory_, network_manager_.get(), &prefs_, nullptr);
    keyring_service_ = std::make_unique<KeyringService>(json_rpc_service_.get(),
                                                        &prefs_, &local_state_);
    ASSERT_TRUE(temp_dir_.CreateUniqueTempDir());
    tx_service_ = std::make_unique<TxService>(
        json_rpc_service_.get(), nullptr, nullptr, keyring_service_.get(),
        &prefs_, temp_dir_.GetPath(),
        base::SequencedTaskRunner::GetCurrentDefault());
    WaitForTxStorageDelegateInitialized(tx_service_->GetDelegateForTesting());
    CreateWallet();

    sol_account_ = SolAccount(0);
    to_account_ = SolAccount(1);
  }

  const mojom::AccountIdPtr& sol_account() { return sol_account_; }
  const mojom::AccountIdPtr& to_account() { return to_account_; }

  void CreateWallet() {
    GetAccountUtils().CreateWallet(kMnemonicDivideCruise, "brave");
  }

  mojom::AccountInfoPtr AddAccount() {
    return keyring_service_->AddAccountSync(
        mojom::CoinType::SOL, mojom::kSolanaKeyringId, "New Account");
  }

  AccountUtils GetAccountUtils() {
    return AccountUtils(keyring_service_.get());
  }

  mojom::AccountIdPtr SolAccount(size_t index) {
    return GetAccountUtils().EnsureSolAccount(index)->account_id->Clone();
  }

  void SetAccountInfoInterceptor(
      const std::map<std::string, std::string> account_owner_map) {
    url_loader_factory_.SetInterceptor(base::BindLambdaForTesting(
        [&, account_owner_map](const network::ResourceRequest& request) {
          url_loader_factory_.ClearResponses();
          std::string_view request_string(request.request_body->elements()
                                              ->at(0)
                                              .As<network::DataElementBytes>()
                                              .AsStringPiece());
          base::Value::Dict request_root =
              base::test::ParseJsonDict(request_string);
          auto* params = request_root.FindList("params");
          ASSERT_TRUE(params && !params->empty() && (*params)[0].is_string());
          std::string account_address = (*params)[0].GetString();
          ASSERT_TRUE(account_owner_map.contains(account_address));

          if (account_owner_map.at(account_address).empty()) {
            url_loader_factory_.AddResponse(request.url.spec(), R"(
                {
                  "jsonrpc":"2.0","id":1,
                  "result":{
                    "context":{"slot":123121238},
                    "value":null
                  }
                })");
            return;
          }

          std::string json = R"(
              {
                "jsonrpc":"2.0","id":1,
                "result": {
                  "context":{"slot":123065869},
                    "value":{
                    "data":["SEVMTE8gV09STEQ=","base64"],
                    "executable":false,
                    "lamports":88801034809120,
                    "owner": "$1",
                    "rentEpoch":284
                  }
                }
              }
          )";
          url_loader_factory_.AddResponse(
              request.url.spec(),
              base::ReplaceStringPlaceholders(
                  json, {account_owner_map.at(account_address)}, nullptr));
        }));
  }

  void SetInterceptors(std::map<GURL, std::string> responses) {
    url_loader_factory_.SetInterceptor(base::BindLambdaForTesting(
        [&, responses](const network::ResourceRequest& request) {
          auto it = responses.find(request.url);
          if (it != responses.end()) {
            std::string response = it->second;
            url_loader_factory_.ClearResponses();
            url_loader_factory_.AddResponse(request.url.spec(), response);
          }
        }));
  }

  void SetInterceptor(
      const std::string& latest_blockhash,
      uint64_t last_valid_block_height,
      const std::string& tx_hash,
      const std::string& content = "",
      bool get_signature_statuses = false,
      uint64_t block_height = 0,
      std::optional<std::string> mock_signature_value = std::nullopt,
      std::optional<base::flat_map<std::string, std::string>>
          rpc_method_responses = std::nullopt) {
    url_loader_factory_.SetInterceptor(base::BindLambdaForTesting(
        [&, latest_blockhash, tx_hash, content, get_signature_statuses,
         last_valid_block_height, block_height, mock_signature_value,
         rpc_method_responses](const network::ResourceRequest& request) {
          url_loader_factory_.ClearResponses();
          std::string_view request_string(request.request_body->elements()
                                              ->at(0)
                                              .As<network::DataElementBytes>()
                                              .AsStringPiece());
          base::Value::Dict request_root =
              base::test::ParseJsonDict(request_string);

          std::string* method = request_root.FindString("method");
          ASSERT_TRUE(method);

          // Check if there's a custom response for the method
          if (rpc_method_responses && rpc_method_responses->contains(*method)) {
            url_loader_factory_.AddResponse(request.url.spec(),
                                            rpc_method_responses->at(*method));
            return;
          }

          if (*method == "getLatestBlockhash") {
            url_loader_factory_.AddResponse(
                request.url.spec(),
                "{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":"
                "{\"context\":{\"slot\":1069},\"value\":{\"blockhash\":\"" +
                    latest_blockhash + "\", \"lastValidBlockHeight\":" +
                    std::to_string(last_valid_block_height) + "}}}");
          } else if (*method == "getBlockHeight") {
            url_loader_factory_.AddResponse(
                request.url.spec(), R"({"jsonrpc":"2.0", "id":1, "result":)" +
                                        std::to_string(block_height) + "}");
          } else if (*method == "sendTransaction") {
            send_transaction_calls_++;
            url_loader_factory_.AddResponse(
                request.url.spec(),
                "{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":\"" + tx_hash +
                    "\"}");
          } else if (*method == "simulateTransaction") {
            url_loader_factory_.AddResponse(request.url.spec(), R"({
              "jsonrpc": "2.0",
              "result": {
                "context": {
                  "apiVersion": "1.17.25",
                  "slot": 259225005
                },
                "value": {
                  "accounts": null,
                  "err": null,
                  "logs": [
                    "Program BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY invoke [1]",
                    "Program log: Instruction: Transfer",
                    "Program BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY success"
                  ],
                  "returnData": null,
                  "unitsConsumed": 69017
                }
              },
              "id": 1
            })");
          } else if (*method == "getAccountInfo" ||
                     *method == "getFeeForMessage") {
            url_loader_factory_.AddResponse(request.url.spec(), content);
          } else if (*method == "getSignatureStatuses") {
            if (!get_signature_statuses) {
              url_loader_factory_.AddResponse(request.url.spec(), "",
                                              net::HTTP_REQUEST_TIMEOUT);
              return;
            }

            if (mock_signature_value) {
              url_loader_factory_.AddResponse(
                  request.url.spec(), base::ReplaceStringPlaceholders(
                                          R"({"jsonrpc": "2.0", "id":1,
                        "result": {"context": {"slot": 82}, "value": $1}})",
                                          {*mock_signature_value}, nullptr));
              return;
            }

            const base::Value::List* params_list =
                request_root.FindList("params");
            ASSERT_TRUE(params_list && (*params_list)[0].is_list());
            const std::string* hash =
                (*params_list)[0].GetList()[0].GetIfString();
            ASSERT_TRUE(hash);
            std::string json;

            // The tx is stored as dict, so we can't gurantee the sequence of
            // hash in the request to be the same as submissions.
            if (*hash == tx_hash1_) {
              json = R"(
                {"jsonrpc":2.0, "id":1, "result":
                  {
                    "context": {"slot": 82},
                    "value": [
                      {
                        "slot": 100,
                        "confirmations": 10,
                        "err": null,
                        "confirmationStatus": "confirmed"
                      },
                      {
                        "slot": 72,
                        "confirmations": 0,
                        "err": null,
                        "confirmationStatus": "finalized"
                      }
                    ]
                  }
                }
              )";
            } else {
              json = R"(
                {"jsonrpc":2.0, "id":1, "result":
                  {
                    "context": {"slot": 82},
                    "value": [
                      {
                        "slot": 72,
                        "confirmations": 0,
                        "err": null,
                        "confirmationStatus": "finalized"
                      },
                      {
                        "slot": 100,
                        "confirmations": 10,
                        "err": null,
                        "confirmationStatus": "confirmed"
                      }
                    ]
                  }
                }
              )";
            }
            url_loader_factory_.AddResponse(request.url.spec(), json);
          } else if (*method == "getRecentPrioritizationFees") {
            url_loader_factory_.AddResponse(request.url.spec(), R"({
              "jsonrpc": "2.0",
              "result": [
                {
                  "prioritizationFee": 100,
                  "slot": 293251906
                },
                {
                  "prioritizationFee": 200,
                  "slot": 293251906
                },
                {
                  "prioritizationFee": 0,
                  "slot": 293251805
                }
              ],
              "id": 1
            })");
          }
        }));
  }

  SolanaTxManager* solana_tx_manager() {
    return static_cast<SolanaTxManager*>(
        tx_service_->GetTxManager(mojom::CoinType::SOL));
  }
  PrefService* prefs() { return &prefs_; }

  url::Origin GetOrigin() const {
    return url::Origin::Create(GURL("https://brave.com"));
  }

  void AddUnapprovedTransaction(const std::string& chain_id,
                                mojom::SolanaTxDataPtr solana_tx_data,
                                const mojom::AccountIdPtr& from,
                                std::string* meta_id) {
    AddUnapprovedTransaction(chain_id, std::move(solana_tx_data), from,
                             GetOrigin(), meta_id);
  }

  void AddUnapprovedTransaction(const std::string& chain_id,
                                mojom::SolanaTxDataPtr solana_tx_data,
                                const mojom::AccountIdPtr& from,
                                const std::optional<url::Origin>& origin,
                                std::string* meta_id) {
    auto tx_data_union =
        mojom::TxDataUnion::NewSolanaTxData(std::move(solana_tx_data));

    base::RunLoop run_loop;
    solana_tx_manager()->AddUnapprovedTransaction(
        chain_id, std::move(tx_data_union), from, origin,
        base::BindLambdaForTesting([&](bool success, const std::string& id,
                                       const std::string& err_message) {
          ASSERT_TRUE(success);
          ASSERT_FALSE(id.empty());
          ASSERT_TRUE(err_message.empty());
          *meta_id = id;
          run_loop.Quit();
        }));
    run_loop.Run();
  }

  void ApproveTransaction(const std::string& meta_id) {
    base::RunLoop run_loop;
    solana_tx_manager()->ApproveTransaction(
        meta_id, base::BindLambdaForTesting(
                     [&](bool success, mojom::ProviderErrorUnionPtr error_union,
                         const std::string& err_message) {
                       ASSERT_TRUE(success);
                       ASSERT_TRUE(error_union->is_solana_provider_error());
                       ASSERT_EQ(error_union->get_solana_provider_error(),
                                 mojom::SolanaProviderError::kSuccess);
                       ASSERT_TRUE(err_message.empty());
                       run_loop.Quit();
                     }));
    run_loop.Run();
  }

  void WaitForUpdatePendingTransactions() { task_environment_.RunUntilIdle(); }

  void TestMakeSystemProgramTransferTxData(
      const std::string& from,
      const std::string& to,
      uint64_t lamports,
      mojom::SolanaTxDataPtr expected_tx_data,
      mojom::SolanaProviderError expected_error,
      const std::string& expected_err_message,
      mojom::SolanaTxDataPtr* tx_data_out = nullptr) {
    base::RunLoop run_loop;
    solana_tx_manager()->MakeSystemProgramTransferTxData(
        from, to, lamports,
        base::BindLambdaForTesting([&](mojom::SolanaTxDataPtr tx_data,
                                       mojom::SolanaProviderError error,
                                       const std::string& err_message) {
          if (tx_data_out) {
            *tx_data_out = std::move(tx_data);
          } else {
            EXPECT_EQ(expected_tx_data, tx_data);
          }
          EXPECT_EQ(expected_error, error);
          EXPECT_EQ(expected_err_message, err_message);
          run_loop.Quit();
        }));
    run_loop.Run();
  }

  void TestMakeSystemProgramTransferTxData(
      const mojom::AccountIdPtr& from,
      const std::string& to,
      uint64_t lamports,
      mojom::SolanaTxDataPtr expected_tx_data,
      mojom::SolanaProviderError expected_error,
      const std::string& expected_err_message,
      mojom::SolanaTxDataPtr* tx_data_out = nullptr) {
    TestMakeSystemProgramTransferTxData(
        from->address, to, lamports, std::move(expected_tx_data),
        std::move(expected_error), std::move(expected_err_message),
        tx_data_out);
  }

  void TestMakeBubbleGumProgramTransferTxData(
      const std::string& chain_id,
      const std::string& token_address,
      const std::string& from_wallet_address,
      const std::string& to_wallet_address,
      mojom::SolanaTxDataPtr expected_tx_data,
      mojom::SolanaProviderError expected_error,
      const std::string& expected_err_message) {
    base::RunLoop run_loop;
    solana_tx_manager()->MakeBubbleGumProgramTransferTxData(
        chain_id, token_address, from_wallet_address, to_wallet_address,
        base::BindLambdaForTesting([&](mojom::SolanaTxDataPtr tx_data,
                                       mojom::SolanaProviderError error,
                                       const std::string& err_message) {
          EXPECT_EQ(expected_tx_data, tx_data);
          EXPECT_EQ(expected_error, error);
          EXPECT_EQ(expected_err_message, err_message);
          run_loop.Quit();
        }));
    run_loop.Run();
  }

  mojom::SolanaTxDataPtr GetSystemProgramTransferTxData(
      const mojom::AccountIdPtr& from,
      const mojom::AccountIdPtr& to,
      uint64_t lamports = 10000000) {
    mojom::SolanaTxDataPtr tx_data;
    TestMakeSystemProgramTransferTxData(from, to->address, lamports, nullptr,
                                        mojom::SolanaProviderError::kSuccess,
                                        "", &tx_data);
    return tx_data;
  }

  void TestMakeTokenProgramTransferTxData(
      base::Location location,
      const std::string& chain_id,
      const std::string& spl_token_mint_address,
      const std::string& from_wallet_address,
      const std::string& to_wallet_address,
      uint64_t amount,
      mojom::SolanaTxDataPtr expected_tx_data,
      mojom::SolanaProviderError expected_error,
      const std::string& expected_err_message) {
    base::RunLoop run_loop;
    SCOPED_TRACE(testing::Message() << location.ToString());
    solana_tx_manager()->MakeTokenProgramTransferTxData(
        chain_id, spl_token_mint_address, from_wallet_address,
        to_wallet_address, amount, 8 /* decimals */,
        base::BindLambdaForTesting([&](mojom::SolanaTxDataPtr tx_data,
                                       mojom::SolanaProviderError error,
                                       const std::string& err_message) {
          EXPECT_EQ(expected_tx_data, tx_data);
          if (expected_tx_data && tx_data) {
            EXPECT_EQ(expected_tx_data->tx_type, tx_data->tx_type);
            EXPECT_EQ(expected_tx_data->instructions, tx_data->instructions);
            EXPECT_EQ(expected_tx_data->message_header,
                      tx_data->message_header);
            EXPECT_EQ(expected_tx_data->static_account_keys,
                      tx_data->static_account_keys);
          }
          EXPECT_EQ(expected_error, error);
          EXPECT_EQ(expected_err_message, err_message);
          run_loop.Quit();
        }));
    run_loop.Run();
  }

  void TestMakeTxDataFromBase64EncodedTransaction(
      const std::string& encoded_transaction,
      const mojom::TransactionType tx_type,
      mojom::SolanaSendTransactionOptionsPtr send_options,
      mojom::SolanaTxDataPtr expected_tx_data,
      mojom::SolanaProviderError expected_error,
      const std::string& expected_err_message) {
    base::RunLoop run_loop;
    solana_tx_manager()->MakeTxDataFromBase64EncodedTransaction(
        encoded_transaction, tx_type, std::move(send_options),
        base::BindLambdaForTesting([&](mojom::SolanaTxDataPtr tx_data,
                                       mojom::SolanaProviderError error,
                                       const std::string& err_message) {
          EXPECT_EQ(expected_tx_data, tx_data);
          EXPECT_EQ(expected_error, error);
          EXPECT_EQ(expected_err_message, err_message);
          run_loop.Quit();
        }));
    run_loop.Run();
  }

  void TestGetTransactionMessageToSign(
      const std::string& tx_meta_id,
      std::optional<std::vector<std::uint8_t>> expected_tx_message) {
    base::RunLoop run_loop;
    solana_tx_manager()->GetTransactionMessageToSign(
        tx_meta_id,
        base::BindLambdaForTesting(
            [&](mojom::MessageToSignUnionPtr tx_message) {
              EXPECT_EQ(!!tx_message, expected_tx_message.has_value());
              if (expected_tx_message.has_value()) {
                ASSERT_TRUE(tx_message->is_message_bytes());
                std::optional<std::vector<std::uint8_t>> message_bytes =
                    tx_message->get_message_bytes();
                EXPECT_EQ(message_bytes, expected_tx_message);
              }
              run_loop.Quit();
            }));
    run_loop.Run();
  }

  void TestProcessSolanaHardwareSignature(
      const std::string& tx_meta_id,
      const std::vector<uint8_t>& signature,
      bool expected_result,
      mojom::SolanaProviderError expected_error,
      const std::string& expected_error_message) {
    base::RunLoop run_loop;
    solana_tx_manager()->ProcessSolanaHardwareSignature(
        tx_meta_id, signature,
        base::BindLambdaForTesting([&](bool result,
                                       mojom::ProviderErrorUnionPtr error_union,
                                       const std::string& error_message) {
          EXPECT_EQ(expected_result, result);
          ASSERT_TRUE(error_union->is_solana_provider_error());
          EXPECT_EQ(error_union->get_solana_provider_error(), expected_error);
          EXPECT_EQ(expected_error_message, error_message);
          run_loop.Quit();
        }));
    run_loop.Run();
  }

  void TestRetryTransaction(const base::Location& location,
                            const std::string& tx_meta_id,
                            bool expected_result,
                            const std::string& expected_err_message,
                            const std::string& expected_blockhash = "") {
    SCOPED_TRACE(testing::Message() << location.ToString());
    MockTxStateManagerObserver observer(
        solana_tx_manager()->GetSolanaTxStateManager());
    if (expected_result) {
      EXPECT_CALL(observer, OnNewUnapprovedTx(testing::_)).Times(1);
    }

    base::RunLoop run_loop;
    solana_tx_manager()->RetryTransaction(
        tx_meta_id,
        base::BindLambdaForTesting([&](bool success, const std::string& id,
                                       const std::string& err_message) {
          EXPECT_EQ(expected_err_message, err_message);
          EXPECT_EQ(expected_result, success);
          if (expected_result) {
            EXPECT_NE(tx_meta_id, id);
            EXPECT_FALSE(id.empty());

            // Get the new tx and check some fields.
            auto tx_meta = solana_tx_manager()->GetTxForTesting(id);
            ASSERT_TRUE(tx_meta);
            EXPECT_EQ(tx_meta->status(), mojom::TransactionStatus::Unapproved);
            EXPECT_TRUE(tx_meta->tx()->raw_signatures().empty());
            EXPECT_EQ(tx_meta->tx()->message()->recent_blockhash(),
                      expected_blockhash);
            EXPECT_EQ(tx_meta->tx()->message()->last_valid_block_height(), 0u);
          } else {
            EXPECT_TRUE(id.empty());
          }
          run_loop.Quit();
        }));
    run_loop.Run();
    testing::Mock::VerifyAndClearExpectations(&observer);
  }

  void TestGetSolanaTxFeeEstimation(
      const std::string& chain_id,
      const std::string& tx_meta_id,
      mojom::SolanaFeeEstimationPtr expected_estimation,
      mojom::SolanaProviderError expected_error,
      const std::string& expected_error_message) {
    base::RunLoop run_loop;
    solana_tx_manager()->GetSolanaTxFeeEstimation(
        chain_id, tx_meta_id,
        base::BindLambdaForTesting([&](mojom::SolanaFeeEstimationPtr estimation,
                                       mojom::SolanaProviderError error,
                                       const std::string& error_message) {
          EXPECT_EQ(expected_error, expected_error);
          EXPECT_EQ(expected_error_message, error_message);
          EXPECT_EQ(expected_estimation, estimation);
          run_loop.Quit();
        }));
    run_loop.Run();
  }

 protected:
  base::test::TaskEnvironment task_environment_;
  base::ScopedTempDir temp_dir_;
  sync_preferences::TestingPrefServiceSyncable prefs_;
  sync_preferences::TestingPrefServiceSyncable local_state_;
  network::TestURLLoaderFactory url_loader_factory_;
  scoped_refptr<network::SharedURLLoaderFactory> shared_url_loader_factory_;
  data_decoder::test::InProcessDataDecoder in_process_data_decoder_;
  std::unique_ptr<NetworkManager> network_manager_;
  std::unique_ptr<JsonRpcService> json_rpc_service_;
  std::unique_ptr<KeyringService> keyring_service_;
  std::unique_ptr<TxService> tx_service_;
  mojom::AccountIdPtr sol_account_;
  mojom::AccountIdPtr to_account_;
  std::string tx_hash1_;
  std::string tx_hash2_;
  std::string latest_blockhash1_;
  std::string latest_blockhash2_;
  std::string latest_blockhash3_;
  uint64_t last_valid_block_height1_ = 0;
  uint64_t last_valid_block_height2_ = 0;
  uint64_t last_valid_block_height3_ = 0;
  size_t send_transaction_calls_ = 0;
  mojom::SolanaFeeEstimationPtr fee_estimation1_;
};

TEST_F(SolanaTxManagerUnitTest, AddAndApproveTransaction) {
  // Stop the block tracker explicitly to make sure it will be started when we
  // submit our pending transactions.
  solana_tx_manager()->GetSolanaBlockTracker()->Stop();

  const auto& from_account = sol_account();
  std::string from_account_address = from_account->address;

  std::string to_account = "JDqrvDz8d8tFCADashbUKQDKfJZFobNy13ugN65t1wvV";
  const std::vector<uint8_t> data = {2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0};

  std::vector<mojom::SolanaAccountMetaPtr> account_metas;
  auto account_meta1 =
      mojom::SolanaAccountMeta::New(from_account_address, nullptr, true, true);
  auto account_meta2 =
      mojom::SolanaAccountMeta::New(to_account, nullptr, false, true);
  account_metas.push_back(std::move(account_meta1));
  account_metas.push_back(std::move(account_meta2));

  auto instruction = mojom::SolanaInstruction::New(
      mojom::kSolanaSystemProgramId, std::move(account_metas), data, nullptr);
  std::vector<mojom::SolanaInstructionPtr> instructions;
  instructions.push_back(std::move(instruction));

  auto solana_tx_data = mojom::SolanaTxData::New(
      "", 0, from_account_address, to_account, "", 10000000, 0,
      mojom::TransactionType::SolanaSystemTransfer, std::move(instructions),
      mojom::SolanaMessageVersion::kLegacy,
      mojom::SolanaMessageHeader::New(1, 0, 1),
      std::vector<std::string>(
          {from_account_address, to_account, mojom::kSolanaSystemProgramId}),
      std::vector<mojom::SolanaMessageAddressTableLookupPtr>(), nullptr,
      nullptr, nullptr);

  // First add a partially signed transaction - it should fetch a base fee
  // but not a priority fee (simulateTransaction + getRecentPrioritizationFees).
  auto param = mojom::SolanaSignTransactionParam::New(
      kEncodedSerializedMessage, std::vector<mojom::SignaturePubkeyPairPtr>());
  param->signatures.emplace_back(mojom::SignaturePubkeyPair::New(
      std::vector<uint8_t>(kSolanaSignatureSize, 1), sol_account()->address));
  solana_tx_data->sign_transaction_param = std::move(param);
  auto tx = SolanaTransaction::FromSolanaTxData(solana_tx_data.Clone());
  ASSERT_TRUE(tx);
  std::string meta_id1;
  SetInterceptor(latest_blockhash1_, last_valid_block_height1_, tx_hash1_,
                 kMockGetFeeForMessageResponse, false,
                 last_valid_block_height1_, std::nullopt);
  AddUnapprovedTransaction(mojom::kSolanaMainnet, solana_tx_data.Clone(),
                           from_account, &meta_id1);
  auto tx_meta1 = solana_tx_manager()->GetTxForTesting(meta_id1);
  ASSERT_TRUE(tx_meta1);
  mojom::SolanaFeeEstimationPtr expected_estimate =
      mojom::SolanaFeeEstimation::New();
  expected_estimate->base_fee = 5000;
  expected_estimate->compute_units = 0;
  expected_estimate->fee_per_compute_unit = 0;
  tx->set_fee_estimation(expected_estimate.Clone());
  EXPECT_EQ(*tx_meta1->tx(), *tx);

  // Remove partial signature
  solana_tx_data->sign_transaction_param = nullptr;
  tx = SolanaTransaction::FromSolanaTxData(solana_tx_data.Clone());
  ASSERT_TRUE(tx);

  // When base fee fetching fails, the tx should not have a fee estimation.
  base::flat_map<std::string, std::string> responses;
  responses["getFeeForMessage"] = "invalid";
  SetInterceptor(latest_blockhash1_, last_valid_block_height1_, tx_hash1_, "",
                 false, last_valid_block_height1_, std::nullopt, responses);
  AddUnapprovedTransaction(mojom::kSolanaMainnet, solana_tx_data.Clone(),
                           from_account, &meta_id1);
  tx_meta1 = solana_tx_manager()->GetTxForTesting(meta_id1);
  ASSERT_TRUE(tx_meta1);
  EXPECT_FALSE(tx_meta1->tx()->fee_estimation());
  responses.clear();

  // When priority fee fetching fails (simulateTransaction), the tx should have
  // a fee estimation, but only base fee should be non zero.
  std::string meta_id2;
  responses["simulateTransaction"] = "invalid";
  SetInterceptor(latest_blockhash1_, last_valid_block_height1_, tx_hash1_,
                 kMockGetFeeForMessageResponse, false,
                 last_valid_block_height1_, std::nullopt, responses);
  AddUnapprovedTransaction(mojom::kSolanaMainnet, solana_tx_data.Clone(),
                           from_account, &meta_id2);
  auto tx_meta2 = solana_tx_manager()->GetTxForTesting(meta_id2);
  ASSERT_TRUE(tx_meta2);
  EXPECT_TRUE(tx_meta2->tx()->fee_estimation());
  EXPECT_EQ(tx_meta2->tx()->fee_estimation()->base_fee, 5000U);
  EXPECT_EQ(tx_meta2->tx()->fee_estimation()->compute_units, 0U);
  EXPECT_EQ(tx_meta2->tx()->fee_estimation()->fee_per_compute_unit, 0U);
  responses.clear();

  // When priority fee fetching fails (getRecentPrioritizationFees),
  // the tx should have a fee estimation, but fee_per_compute_unit should
  // be the default.
  std::string meta_id3;
  responses["getRecentPrioritizationFees"] = "invalid";
  SetInterceptor(latest_blockhash1_, last_valid_block_height1_, tx_hash1_,
                 kMockGetFeeForMessageResponse, false,
                 last_valid_block_height1_, std::nullopt, responses);

  AddUnapprovedTransaction(mojom::kSolanaMainnet, solana_tx_data.Clone(),
                           from_account, &meta_id3);
  auto tx_meta3 = solana_tx_manager()->GetTxForTesting(meta_id3);
  ASSERT_TRUE(tx_meta3);
  EXPECT_TRUE(tx_meta3->tx()->fee_estimation());
  EXPECT_EQ(tx_meta3->tx()->fee_estimation()->base_fee, 5000U);
  EXPECT_EQ(tx_meta3->tx()->fee_estimation()->compute_units, 76249U);
  EXPECT_EQ(tx_meta3->tx()->fee_estimation()->fee_per_compute_unit, 1U);

  // When `everything is successful, the tx should have a fee estimation with
  // each of base_fee, compute_units and fee_per_compute_unit set from data in
  // RPC responses
  std::string meta_id4;
  SetInterceptor(latest_blockhash1_, last_valid_block_height1_, tx_hash1_,
                 kMockGetFeeForMessageResponse, false,
                 last_valid_block_height1_);
  AddUnapprovedTransaction(mojom::kSolanaMainnet, solana_tx_data.Clone(),
                           from_account, &meta_id4);

  auto tx_meta4 = solana_tx_manager()->GetTxForTesting(meta_id4);
  ASSERT_TRUE(tx_meta4);
  EXPECT_EQ(tx_meta4->chain_id(), mojom::kSolanaMainnet);
  tx->message()->AddPriorityFee(
      76249U,
      100);  // Added priority automatically in AddUnapprovedTransaction
  tx->set_fee_estimation(fee_estimation1_.Clone());
  EXPECT_EQ(*tx_meta4->tx(), *tx);
  EXPECT_EQ(tx_meta4->signature_status(), SolanaSignatureStatus());
  EXPECT_EQ(tx_meta4->from(), from_account);
  EXPECT_EQ(tx_meta4->status(), mojom::TransactionStatus::Unapproved);

  std::string meta_id5;
  AddUnapprovedTransaction(mojom::kSolanaMainnet, solana_tx_data.Clone(),
                           from_account, &meta_id5);
  auto tx_meta5 = solana_tx_manager()->GetTxForTesting(meta_id5);
  ASSERT_TRUE(tx_meta5);
  EXPECT_EQ(tx_meta5->chain_id(), mojom::kSolanaMainnet);
  EXPECT_EQ(*tx_meta5->tx(), *tx);
  EXPECT_EQ(tx_meta5->signature_status(), SolanaSignatureStatus());
  EXPECT_EQ(tx_meta5->from(), from_account);
  EXPECT_EQ(tx_meta5->status(), mojom::TransactionStatus::Unapproved);

  ApproveTransaction(meta_id4);
  WaitForUpdatePendingTransactions();

  tx->message()->set_recent_blockhash(latest_blockhash1_);
  tx->message()->set_last_valid_block_height(last_valid_block_height1_);
  tx->set_wired_tx(
      tx->GetSignedTransaction(keyring_service_.get(), from_account));

  tx_meta4 = solana_tx_manager()->GetTxForTesting(meta_id4);
  ASSERT_TRUE(tx_meta4);
  EXPECT_EQ(tx_meta4->chain_id(), mojom::kSolanaMainnet);
  EXPECT_EQ(*tx_meta4->tx(), *tx);
  EXPECT_EQ(tx_meta4->signature_status(), SolanaSignatureStatus());
  EXPECT_EQ(tx_meta4->from(), from_account);
  EXPECT_EQ(tx_meta4->status(), mojom::TransactionStatus::Submitted);
  EXPECT_EQ(tx_meta4->tx_hash(), tx_hash1_);

  // Send another tx.
  SetInterceptor(latest_blockhash1_, last_valid_block_height1_, tx_hash2_, "",
                 false, last_valid_block_height1_);
  ApproveTransaction(meta_id5);
  WaitForUpdatePendingTransactions();

  tx_meta5 = solana_tx_manager()->GetTxForTesting(meta_id5);
  ASSERT_TRUE(tx_meta5);
  EXPECT_EQ(tx_meta5->chain_id(), mojom::kSolanaMainnet);
  EXPECT_EQ(*tx_meta5->tx(), *tx);
  EXPECT_EQ(tx_meta5->signature_status(), SolanaSignatureStatus());
  EXPECT_EQ(tx_meta5->from(), from_account);
  EXPECT_EQ(tx_meta5->status(), mojom::TransactionStatus::Submitted);
  EXPECT_EQ(tx_meta5->tx_hash(), tx_hash2_);

  // Fast forward to have block tracker run with current interceptor.
  task_environment_.FastForwardBy(
      base::Seconds(kSolanaBlockTrackerTimeInSeconds));

  SetInterceptor(latest_blockhash2_, last_valid_block_height2_, tx_hash2_, "",
                 true, last_valid_block_height1_);

  // Fast forward again to have block tracker run with the new interceptor.
  task_environment_.FastForwardBy(
      base::Seconds(kSolanaBlockTrackerTimeInSeconds));
  tx_meta4 = solana_tx_manager()->GetTxForTesting(meta_id4);
  EXPECT_EQ(mojom::TransactionStatus::Submitted, tx_meta4->status());
  EXPECT_EQ(tx_meta4->signature_status(),
            SolanaSignatureStatus(100u, 10u, "", "confirmed"));

  tx_meta5 = solana_tx_manager()->GetTxForTesting(meta_id5);
  EXPECT_EQ(mojom::TransactionStatus::Confirmed, tx_meta5->status());
  EXPECT_EQ(tx_meta5->signature_status(),
            SolanaSignatureStatus(72u, 0u, "", "finalized"));
}

TEST_F(SolanaTxManagerUnitTest, OfacSanctionedToAddress) {
  const auto& from = sol_account();
  const std::string ofac_sanctioned_to =
      "FepMPR8vahkJ98Fr22VKbfHU4f4PTAyi18PDZN2NooPb";
  auto* registry = BlockchainRegistry::GetInstance();
  registry->UpdateOfacAddressesList({base::ToLowerASCII(ofac_sanctioned_to)});
  TestMakeSystemProgramTransferTxData(
      from, ofac_sanctioned_to, 10000000, nullptr,
      mojom::SolanaProviderError::kInvalidParams,
      l10n_util::GetStringUTF8(IDS_WALLET_OFAC_RESTRICTION), nullptr);
}

TEST_F(SolanaTxManagerUnitTest, WalletOrigin) {
  const auto& from = sol_account();
  const std::string to = "JDqrvDz8d8tFCADashbUKQDKfJZFobNy13ugN65t1wvV";
  mojom::SolanaTxDataPtr system_transfer_data = nullptr;
  TestMakeSystemProgramTransferTxData(from, to, 10000000, nullptr,
                                      mojom::SolanaProviderError::kSuccess, "",
                                      &system_transfer_data);
  ASSERT_TRUE(system_transfer_data);

  SetInterceptor(latest_blockhash1_, last_valid_block_height1_, tx_hash1_,
                 kMockGetFeeForMessageResponse, false,
                 last_valid_block_height1_);

  std::string meta_id;
  AddUnapprovedTransaction(mojom::kSolanaMainnet,
                           std::move(system_transfer_data), from, std::nullopt,
                           &meta_id);

  auto tx_meta = solana_tx_manager()->GetTxForTesting(meta_id);
  ASSERT_TRUE(tx_meta);
  EXPECT_EQ(tx_meta->chain_id(), mojom::kSolanaMainnet);
  EXPECT_EQ(tx_meta->origin(), url::Origin::Create(GURL("chrome://wallet")));
}

TEST_F(SolanaTxManagerUnitTest, SomeSiteOrigin) {
  const auto& from = sol_account();
  const std::string to = "JDqrvDz8d8tFCADashbUKQDKfJZFobNy13ugN65t1wvV";
  mojom::SolanaTxDataPtr system_transfer_data = nullptr;
  TestMakeSystemProgramTransferTxData(from, to, 10000000, nullptr,
                                      mojom::SolanaProviderError::kSuccess, "",
                                      &system_transfer_data);
  ASSERT_TRUE(system_transfer_data);

  SetInterceptor(latest_blockhash1_, last_valid_block_height1_, tx_hash1_,
                 kMockGetFeeForMessageResponse, false,
                 last_valid_block_height1_);
  std::string meta_id;
  AddUnapprovedTransaction(
      mojom::kSolanaMainnet, std::move(system_transfer_data), from,
      url::Origin::Create(GURL("https://some.site.com")), &meta_id);

  auto tx_meta = solana_tx_manager()->GetTxForTesting(meta_id);
  ASSERT_TRUE(tx_meta);
  EXPECT_EQ(tx_meta->chain_id(), mojom::kSolanaMainnet);
  EXPECT_EQ(tx_meta->origin(),
            url::Origin::Create(GURL("https://some.site.com")));
}

TEST_F(SolanaTxManagerUnitTest, MakeSystemProgramTransferTxData) {
  const auto& from_account = sol_account();
  std::string from_account_address = from_account->address;
  std::string to_account = "JDqrvDz8d8tFCADashbUKQDKfJZFobNy13ugN65t1wvV";
  const std::vector<uint8_t> data = {2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0};

  auto solana_account_meta1 =
      mojom::SolanaAccountMeta::New(from_account_address, nullptr, true, true);
  auto solana_account_meta2 =
      mojom::SolanaAccountMeta::New(to_account, nullptr, false, true);
  std::vector<mojom::SolanaAccountMetaPtr> account_metas;
  account_metas.push_back(std::move(solana_account_meta1));
  account_metas.push_back(std::move(solana_account_meta2));

  auto mojom_param = mojom::SolanaInstructionParam::New(
      "lamports", "Lamports", "10000000",
      mojom::SolanaInstructionParamType::kUint64);
  std::vector<mojom::SolanaInstructionParamPtr> mojom_params;
  mojom_params.emplace_back(std::move(mojom_param));
  auto mojom_decoded_data = mojom::DecodedSolanaInstructionData::New(
      static_cast<uint32_t>(mojom::SolanaSystemInstruction::kTransfer),
      solana_ins_data_decoder::GetMojomAccountParamsForTesting(
          mojom::SolanaSystemInstruction::kTransfer, std::nullopt),
      std::move(mojom_params));

  auto mojom_instruction = mojom::SolanaInstruction::New(
      mojom::kSolanaSystemProgramId, std::move(account_metas), data,
      std::move(mojom_decoded_data));

  std::vector<mojom::SolanaInstructionPtr> instructions;
  instructions.push_back(std::move(mojom_instruction));

  auto tx_data = mojom::SolanaTxData::New(
      "", 0, from_account_address, to_account, "", 10000000, 0,
      mojom::TransactionType::SolanaSystemTransfer, std::move(instructions),
      mojom::SolanaMessageVersion::kLegacy,
      mojom::SolanaMessageHeader::New(1, 0, 1),
      std::vector<std::string>(
          {from_account_address, to_account, mojom::kSolanaSystemProgramId}),
      std::vector<mojom::SolanaMessageAddressTableLookupPtr>(), nullptr,
      nullptr, nullptr);

  TestMakeSystemProgramTransferTxData(from_account, to_account, 10000000,
                                      std::move(tx_data),
                                      mojom::SolanaProviderError::kSuccess, "");

  TestMakeSystemProgramTransferTxData(
      "", to_account, 10000000, nullptr,
      mojom::SolanaProviderError::kInternalError,
      l10n_util::GetStringUTF8(IDS_WALLET_INTERNAL_ERROR));
  TestMakeSystemProgramTransferTxData(
      from_account, "", 10000000, nullptr,
      mojom::SolanaProviderError::kInternalError,
      l10n_util::GetStringUTF8(IDS_WALLET_INTERNAL_ERROR));
}

class TokenProgramTest
    : public SolanaTxManagerUnitTest,
      public testing::WithParamInterface<mojom::SPLTokenProgram> {};

TEST_P(TokenProgramTest, MakeTokenProgramTransferTxData) {
  mojom::SPLTokenProgram token_program = GetParam();
  const std::string token_program_id =
      SPLTokenProgramToProgramID(token_program);

  // Test receiving associated token account exists.
  std::string from_wallet_address =
      "BrG44HdsEhzapvs8bEqzvkq4egwevS3fRE6ze2ENo6S8";
  std::string to_wallet_address =
      "JDqrvDz8d8tFCADashbUKQDKfJZFobNy13ugN65t1wvV";
  std::string spl_token_mint_address =
      "AQoKYV7tYpTrFZN6P5oUufbQKAUr9mNYGe1TTJC9wajM";

  auto from_associated_token_account = SolanaKeyring::GetAssociatedTokenAccount(
      spl_token_mint_address, from_wallet_address, token_program);
  ASSERT_TRUE(from_associated_token_account);
  auto to_associated_token_account = SolanaKeyring::GetAssociatedTokenAccount(
      spl_token_mint_address, to_wallet_address, token_program);
  ASSERT_TRUE(to_associated_token_account);

  const std::vector<uint8_t> data = {12, 128, 150, 152, 0, 0, 0, 0, 0, 8};

  auto solana_account_meta1 = mojom::SolanaAccountMeta::New(
      *from_associated_token_account, nullptr, false, true);
  auto mint_account_meta = mojom::SolanaAccountMeta::New(spl_token_mint_address,
                                                         nullptr, false, false);
  auto solana_account_meta2 = mojom::SolanaAccountMeta::New(
      *to_associated_token_account, nullptr, false, true);
  auto solana_account_meta3 =
      mojom::SolanaAccountMeta::New(from_wallet_address, nullptr, true, false);
  std::vector<mojom::SolanaAccountMetaPtr> account_metas;
  account_metas.push_back(std::move(solana_account_meta1));
  account_metas.push_back(mint_account_meta.Clone());
  account_metas.push_back(std::move(solana_account_meta2));
  account_metas.push_back(std::move(solana_account_meta3));

  auto mojom_param = mojom::SolanaInstructionParam::New(
      "amount", "Amount", "10000000",
      mojom::SolanaInstructionParamType::kUint64);
  auto mojom_decimals_param = mojom::SolanaInstructionParam::New(
      "decimals", "Decimals", "8", mojom::SolanaInstructionParamType::kUint8);
  std::vector<mojom::SolanaInstructionParamPtr> mojom_params;
  mojom_params.emplace_back(std::move(mojom_param));
  mojom_params.emplace_back(std::move(mojom_decimals_param));
  auto mojom_decoded_data = mojom::DecodedSolanaInstructionData::New(
      static_cast<uint32_t>(mojom::SolanaTokenInstruction::kTransferChecked),
      solana_ins_data_decoder::GetMojomAccountParamsForTesting(
          std::nullopt, mojom::SolanaTokenInstruction::kTransferChecked),
      std::move(mojom_params));

  auto mojom_transfer_instruction =
      mojom::SolanaInstruction::New(token_program_id, std::move(account_metas),
                                    data, std::move(mojom_decoded_data));

  std::vector<mojom::SolanaInstructionPtr> instructions;
  instructions.push_back(mojom_transfer_instruction.Clone());
  auto tx_data = mojom::SolanaTxData::New(
      "", 0, from_wallet_address, to_wallet_address, spl_token_mint_address, 0,
      10000000, mojom::TransactionType::SolanaSPLTokenTransfer,
      std::move(instructions), mojom::SolanaMessageVersion::kLegacy,
      mojom::SolanaMessageHeader::New(1, 0, 2),
      std::vector<std::string>({from_wallet_address,
                                *from_associated_token_account,
                                *to_associated_token_account, token_program_id,
                                spl_token_mint_address}),
      std::vector<mojom::SolanaMessageAddressTableLookupPtr>(), nullptr,
      nullptr, nullptr);

  // Owner is the token program account.
  std::string json = R"(
    {
      "jsonrpc":"2.0","id":1,
      "result": {
        "context":{"slot":123065869},
        "value":{
          "data":["SEVMTE8gV09STEQ=","base64"],
          "executable":false,
          "lamports":88801034809120,
          "owner":"$1",
          "rentEpoch":284
        }
      }
    }
  )";

  SetInterceptor(
      "", 0, "",
      base::ReplaceStringPlaceholders(json, {token_program_id}, nullptr));
  TestMakeTokenProgramTransferTxData(
      FROM_HERE, mojom::kSolanaMainnet, spl_token_mint_address,
      from_wallet_address, to_wallet_address, 10000000, std::move(tx_data),
      mojom::SolanaProviderError::kSuccess, "");

  account_metas.clear();
  auto solana_account_meta4 =
      mojom::SolanaAccountMeta::New(from_wallet_address, nullptr, true, true);
  auto solana_account_meta5 = mojom::SolanaAccountMeta::New(
      *to_associated_token_account, nullptr, false, true);
  auto solana_account_meta6 =
      mojom::SolanaAccountMeta::New(to_wallet_address, nullptr, false, false);
  auto solana_account_meta7 = mojom::SolanaAccountMeta::New(
      spl_token_mint_address, nullptr, false, false);
  auto solana_account_meta8 = mojom::SolanaAccountMeta::New(
      mojom::kSolanaSystemProgramId, nullptr, false, false);
  auto solana_account_meta9 =
      mojom::SolanaAccountMeta::New(token_program_id, nullptr, false, false);
  account_metas.push_back(std::move(solana_account_meta4));
  account_metas.push_back(std::move(solana_account_meta5));
  account_metas.push_back(std::move(solana_account_meta6));
  account_metas.push_back(std::move(solana_account_meta7));
  account_metas.push_back(std::move(solana_account_meta8));
  account_metas.push_back(std::move(solana_account_meta9));

  instructions.clear();
  auto mojom_create_associated_account_instruction =
      mojom::SolanaInstruction::New(mojom::kSolanaAssociatedTokenProgramId,
                                    std::move(account_metas),
                                    std::vector<uint8_t>(), nullptr);
  instructions.push_back(
      std::move(mojom_create_associated_account_instruction));
  instructions.push_back(std::move(mojom_transfer_instruction));
  tx_data = mojom::SolanaTxData::New(
      "", 0, from_wallet_address, to_wallet_address, spl_token_mint_address, 0,
      10000000,
      mojom::TransactionType::
          SolanaSPLTokenTransferWithAssociatedTokenAccountCreation,
      std::move(instructions), mojom::SolanaMessageVersion::kLegacy,
      mojom::SolanaMessageHeader::New(1, 0, 5),
      std::vector<std::string>(
          {from_wallet_address, *to_associated_token_account,
           *from_associated_token_account,
           mojom::kSolanaAssociatedTokenProgramId, to_wallet_address,
           spl_token_mint_address, mojom::kSolanaSystemProgramId,
           token_program_id}),
      std::vector<mojom::SolanaMessageAddressTableLookupPtr>(), nullptr,
      nullptr, nullptr);

  // Test owner is not token program account.
  SetAccountInfoInterceptor(
      {{spl_token_mint_address, token_program_id},
       {*to_associated_token_account, "11111111111111111111111111111111"}});
  TestMakeTokenProgramTransferTxData(
      FROM_HERE, mojom::kSolanaMainnet, spl_token_mint_address,
      from_wallet_address, to_wallet_address, 10000000, tx_data.Clone(),
      mojom::SolanaProviderError::kSuccess, "");

  // Test receiving associated token account does not exist.
  SetAccountInfoInterceptor({{spl_token_mint_address, token_program_id},
                             {*to_associated_token_account, ""}});
  TestMakeTokenProgramTransferTxData(
      FROM_HERE, mojom::kSolanaMainnet, spl_token_mint_address,
      from_wallet_address, to_wallet_address, 10000000, std::move(tx_data),
      mojom::SolanaProviderError::kSuccess, "");

  // Empty addresses should be handled.
  TestMakeTokenProgramTransferTxData(
      FROM_HERE, mojom::kSolanaMainnet, "", to_wallet_address,
      spl_token_mint_address, 10000000, nullptr,
      mojom::SolanaProviderError::kInvalidParams,
      l10n_util::GetStringUTF8(IDS_WALLET_INVALID_PARAMETERS));
  TestMakeTokenProgramTransferTxData(
      FROM_HERE, mojom::kSolanaMainnet, from_wallet_address, "",
      spl_token_mint_address, 10000000, nullptr,
      mojom::SolanaProviderError::kInvalidParams,
      l10n_util::GetStringUTF8(IDS_WALLET_INVALID_PARAMETERS));
  TestMakeTokenProgramTransferTxData(
      FROM_HERE, mojom::kSolanaMainnet, from_wallet_address, to_wallet_address,
      "", 10000000, nullptr, mojom::SolanaProviderError::kInvalidParams,
      l10n_util::GetStringUTF8(IDS_WALLET_INVALID_PARAMETERS));

  // Test sending to OFAC Sanctioned address
  const std::string ofac_sanctioned_to =
      "FepMPR8vahkJ98Fr22VKbfHU4f4PTAyi18PDZN2NooPb";
  auto* registry = BlockchainRegistry::GetInstance();
  registry->UpdateOfacAddressesList({base::ToLowerASCII(ofac_sanctioned_to)});
  TestMakeTokenProgramTransferTxData(
      FROM_HERE, mojom::kSolanaMainnet, spl_token_mint_address,
      from_wallet_address, ofac_sanctioned_to, 10000000, std::move(tx_data),
      mojom::SolanaProviderError::kInvalidParams,
      l10n_util::GetStringUTF8(IDS_WALLET_OFAC_RESTRICTION));
}

INSTANTIATE_TEST_SUITE_P(TokenProgramTest,
                         TokenProgramTest,
                         testing::Values(mojom::SPLTokenProgram::kToken,
                                         mojom::SPLTokenProgram::kToken2022));

TEST_F(SolanaTxManagerUnitTest, MakeTxDataFromBase64EncodedTransaction) {
  // OK: TX data from base64-encoded transaction.
  // Data from SolanaTransactionUnitTest.FromSignedTransactionBytes
  const std::string& encoded_transaction =
      "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
      "AAAAAAAAAAAAAAABAAEDoTNZW3PS2dRMn6vIKJadRsVHGCzRbI8EOvvXPsmsn8X/"
      "4OT1Xu4XhM4oUvnby2eebttd+Y+"
      "Gz6yzTEMGqaSVJgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg79TyWzB3v+"
      "wQ4jR2yoGqfCJjrmpBhFXewYqN6JAeFsBAgIAAQwCAAAAgJaYAAAAAAA=";
  const std::string& from_account =
      "BrG44HdsEhzapvs8bEqzvkq4egwevS3fRE6ze2ENo6S8";
  const std::string& to_account =
      "JDqrvDz8d8tFCADashbUKQDKfJZFobNy13ugN65t1wvV";
  const std::string& recent_blockhash =
      "9sHcv6xwn9YkB8nxTUGKDwPwNnmqVp5oAXxU8Fdkm4J6";
  const std::vector<uint8_t> data = {2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0};
  auto solana_account_meta1 =
      mojom::SolanaAccountMeta::New(from_account, nullptr, true, true);
  auto solana_account_meta2 =
      mojom::SolanaAccountMeta::New(to_account, nullptr, false, true);
  std::vector<mojom::SolanaAccountMetaPtr> account_metas;
  account_metas.push_back(std::move(solana_account_meta1));
  account_metas.push_back(std::move(solana_account_meta2));

  auto mojom_param = mojom::SolanaInstructionParam::New(
      "lamports", "Lamports", "10000000",
      mojom::SolanaInstructionParamType::kUint64);
  std::vector<mojom::SolanaInstructionParamPtr> mojom_params;
  mojom_params.emplace_back(std::move(mojom_param));
  auto mojom_decoded_data = mojom::DecodedSolanaInstructionData::New(
      static_cast<uint32_t>(mojom::SolanaSystemInstruction::kTransfer),
      solana_ins_data_decoder::GetMojomAccountParamsForTesting(
          mojom::SolanaSystemInstruction::kTransfer, std::nullopt),
      std::move(mojom_params));

  auto mojom_instruction = mojom::SolanaInstruction::New(
      // Program ID
      mojom::kSolanaSystemProgramId,
      // Accounts
      std::move(account_metas),
      // Data
      data,
      // Decoded Data
      std::move(mojom_decoded_data));
  std::vector<mojom::SolanaInstructionPtr> instructions;
  instructions.push_back(std::move(mojom_instruction));
  auto send_options =
      SolanaTransaction::SendOptions(std::nullopt, std::nullopt, true);
  auto tx_data = mojom::SolanaTxData::New(
      recent_blockhash, 0, from_account, "", "", 0, 0,
      mojom::TransactionType::SolanaSwap, std::move(instructions),
      mojom::SolanaMessageVersion::kLegacy,
      mojom::SolanaMessageHeader::New(1, 0, 1),
      std::vector<std::string>(
          {from_account, to_account, mojom::kSolanaSystemProgramId}),
      std::vector<mojom::SolanaMessageAddressTableLookupPtr>(),
      send_options.ToMojomSendOptions(), nullptr, nullptr);
  TestMakeTxDataFromBase64EncodedTransaction(
      encoded_transaction, mojom::TransactionType::SolanaSwap,
      send_options.ToMojomSendOptions(), std::move(tx_data),
      mojom::SolanaProviderError::kSuccess, "");

  // KO: empty message
  TestMakeTxDataFromBase64EncodedTransaction(
      "", mojom::TransactionType::SolanaSwap, nullptr, nullptr,
      mojom::SolanaProviderError::kInternalError,
      l10n_util::GetStringUTF8(IDS_WALLET_INTERNAL_ERROR));

  // KO: invalid base64 message
  TestMakeTxDataFromBase64EncodedTransaction(
      "not a base64 message", mojom::TransactionType::SolanaSwap, nullptr,
      nullptr, mojom::SolanaProviderError::kInternalError,
      l10n_util::GetStringUTF8(IDS_WALLET_INTERNAL_ERROR));

  // KO: valid base64 message, but invalid transaction bytes
  TestMakeTxDataFromBase64EncodedTransaction(
      "YW5p", mojom::TransactionType::SolanaSwap, nullptr, nullptr,
      mojom::SolanaProviderError::kInternalError,
      l10n_util::GetStringUTF8(IDS_WALLET_INTERNAL_ERROR));
}

TEST_F(SolanaTxManagerUnitTest, DropTxWithInvalidBlockhash) {
  const auto& from = sol_account();
  const std::string to = "JDqrvDz8d8tFCADashbUKQDKfJZFobNy13ugN65t1wvV";
  mojom::SolanaTxDataPtr system_transfer_data = nullptr;
  TestMakeSystemProgramTransferTxData(from, to, 10000000, nullptr,
                                      mojom::SolanaProviderError::kSuccess, "",
                                      &system_transfer_data);
  ASSERT_TRUE(system_transfer_data);

  SetInterceptor(latest_blockhash1_, last_valid_block_height1_, tx_hash1_, "",
                 false, last_valid_block_height1_);
  std::string meta_id1;
  AddUnapprovedTransaction(mojom::kSolanaMainnet, system_transfer_data.Clone(),
                           from, &meta_id1);
  ASSERT_FALSE(meta_id1.empty());
  ApproveTransaction(meta_id1);

  SetInterceptor(latest_blockhash2_, last_valid_block_height2_, tx_hash2_, "",
                 false, last_valid_block_height1_);
  // Fast forward to have block tracker run with the new interceptor.
  task_environment_.FastForwardBy(
      base::Seconds(kSolanaBlockTrackerTimeInSeconds));

  std::string meta_id2;
  AddUnapprovedTransaction(mojom::kSolanaMainnet, system_transfer_data.Clone(),
                           from, &meta_id2);
  ASSERT_FALSE(meta_id2.empty());
  ApproveTransaction(meta_id2);

  WaitForUpdatePendingTransactions();

  // Check two submitted tx.
  auto pending_transactions =
      solana_tx_manager()->GetSolanaTxStateManager()->GetTransactionsByStatus(
          mojom::kSolanaMainnet, mojom::TransactionStatus::Submitted,
          std::nullopt);
  EXPECT_EQ(pending_transactions.size(), 2u);
  auto tx1 = solana_tx_manager()->GetTxForTesting(meta_id1);
  ASSERT_TRUE(tx1);
  EXPECT_EQ(tx1->status(), mojom::TransactionStatus::Submitted);
  EXPECT_EQ(tx1->tx()->message()->recent_blockhash(), latest_blockhash1_);
  EXPECT_EQ(tx1->tx()->message()->last_valid_block_height(),
            last_valid_block_height1_);

  auto tx2 = solana_tx_manager()->GetTxForTesting(meta_id2);
  ASSERT_TRUE(tx2);
  EXPECT_EQ(tx2->status(), mojom::TransactionStatus::Submitted);
  EXPECT_EQ(tx2->tx()->message()->recent_blockhash(), latest_blockhash2_);
  EXPECT_EQ(tx2->tx()->message()->last_valid_block_height(),
            last_valid_block_height2_);

  // Set Interceptor for return null signature statuses and block height only
  // valid for blockhash2.
  SetInterceptor(latest_blockhash3_, last_valid_block_height3_, "", "", true,
                 last_valid_block_height2_, "[null, null]");
  // Fast forward to have block tracker run with the new interceptor.
  task_environment_.FastForwardBy(
      base::Seconds(kSolanaBlockTrackerTimeInSeconds));
  WaitForUpdatePendingTransactions();

  // Check blockhash1 should be dropped, blockhash2 stay as submitted.
  auto dropped_transactions =
      solana_tx_manager()->GetSolanaTxStateManager()->GetTransactionsByStatus(
          mojom::kSolanaMainnet, mojom::TransactionStatus::Dropped,
          std::nullopt);
  ASSERT_EQ(dropped_transactions.size(), 1u);
  EXPECT_EQ(dropped_transactions[0]->id(), meta_id1);

  pending_transactions =
      solana_tx_manager()->GetSolanaTxStateManager()->GetTransactionsByStatus(
          mojom::kSolanaMainnet, mojom::TransactionStatus::Submitted,
          std::nullopt);
  ASSERT_EQ(pending_transactions.size(), 1u);
  EXPECT_EQ(pending_transactions[0]->id(), meta_id2);
}

TEST_F(SolanaTxManagerUnitTest, DropTxWithInvalidBlockhash_DappBlockhash) {
  mojom::SolanaTxDataPtr system_transfer_data =
      GetSystemProgramTransferTxData(sol_account(), to_account());
  ASSERT_TRUE(system_transfer_data);
  system_transfer_data->recent_blockhash = latest_blockhash1_;
  ASSERT_EQ(system_transfer_data->last_valid_block_height, 0u);

  SetInterceptor(latest_blockhash1_, last_valid_block_height1_, tx_hash1_,
                 kMockGetFeeForMessageResponse, false,
                 last_valid_block_height1_);
  std::string meta_id1;
  AddUnapprovedTransaction(mojom::kSolanaMainnet, system_transfer_data.Clone(),
                           sol_account(), &meta_id1);
  ASSERT_FALSE(meta_id1.empty());
  ApproveTransaction(meta_id1);

  std::string meta_id2;
  auto system_transfer_data2 = system_transfer_data.Clone();
  system_transfer_data2->recent_blockhash = latest_blockhash2_;
  system_transfer_data2->last_valid_block_height = 0;
  AddUnapprovedTransaction(mojom::kSolanaMainnet,
                           std::move(system_transfer_data2), sol_account(),
                           &meta_id2);
  ASSERT_FALSE(meta_id2.empty());
  ApproveTransaction(meta_id2);

  auto tx_meta2 = solana_tx_manager()->GetTxForTesting(meta_id2);
  ASSERT_TRUE(tx_meta2);
  ASSERT_EQ(tx_meta2->tx()->message()->last_valid_block_height(),
            last_valid_block_height1_ + kSolanaValidBlockHeightThreshold);
  tx_meta2->tx()->message()->set_last_valid_block_height(
      last_valid_block_height2_ + kSolanaValidBlockHeightThreshold);
  ASSERT_TRUE(
      solana_tx_manager()->GetSolanaTxStateManager()->AddOrUpdateTx(*tx_meta2));

  WaitForUpdatePendingTransactions();

  // Last valid block height should be set during ApproveTransaction.
  auto tx_meta = solana_tx_manager()->GetTxForTesting(meta_id1);
  ASSERT_TRUE(tx_meta);
  ASSERT_EQ(tx_meta->tx()->message()->recent_blockhash(), latest_blockhash1_);
  ASSERT_EQ(tx_meta->tx()->message()->last_valid_block_height(),
            last_valid_block_height1_ + kSolanaValidBlockHeightThreshold);
  EXPECT_EQ(tx_meta->status(), mojom::TransactionStatus::Submitted);

  tx_meta2 = solana_tx_manager()->GetTxForTesting(meta_id2);
  ASSERT_TRUE(tx_meta2);
  ASSERT_EQ(tx_meta2->tx()->message()->recent_blockhash(), latest_blockhash2_);
  ASSERT_EQ(tx_meta2->tx()->message()->last_valid_block_height(),
            last_valid_block_height2_ + 150);
  EXPECT_EQ(tx_meta2->status(), mojom::TransactionStatus::Submitted);

  ASSERT_TRUE(solana_tx_manager()->GetSolanaBlockTracker()->IsRunning(
      mojom::kSolanaMainnet));

  // Trigger block tracker to run, with block_height < last_valid_block_height.
  // Transaction stay as submitted.
  task_environment_.FastForwardBy(
      base::Seconds(kSolanaBlockTrackerTimeInSeconds));
  WaitForUpdatePendingTransactions();

  tx_meta = solana_tx_manager()->GetTxForTesting(meta_id1);
  ASSERT_TRUE(tx_meta);
  EXPECT_EQ(tx_meta->status(), mojom::TransactionStatus::Submitted);

  tx_meta2 = solana_tx_manager()->GetTxForTesting(meta_id2);
  ASSERT_TRUE(tx_meta2);
  EXPECT_EQ(tx_meta2->status(), mojom::TransactionStatus::Submitted);

  ASSERT_TRUE(solana_tx_manager()->GetSolanaBlockTracker()->IsRunning(
      mojom::kSolanaMainnet));

  // Fast forward to have block tracker run with the new interceptor, where
  // block_height > last_valid_block_height.
  // Transaction should be dropped.
  SetInterceptor(latest_blockhash2_, last_valid_block_height2_, "", "", true,
                 last_valid_block_height1_ + 151, "[null, null]");
  task_environment_.FastForwardBy(
      base::Seconds(kSolanaBlockTrackerTimeInSeconds));
  WaitForUpdatePendingTransactions();

  tx_meta = solana_tx_manager()->GetTxForTesting(meta_id1);
  ASSERT_TRUE(tx_meta);
  EXPECT_EQ(tx_meta->status(), mojom::TransactionStatus::Dropped);

  tx_meta2 = solana_tx_manager()->GetTxForTesting(meta_id2);
  ASSERT_TRUE(tx_meta2);
  EXPECT_EQ(tx_meta2->status(), mojom::TransactionStatus::Submitted);
}

TEST_F(SolanaTxManagerUnitTest, DropTxAfterSafeDropThreshold) {
  const auto& from = sol_account();
  const std::string to = "JDqrvDz8d8tFCADashbUKQDKfJZFobNy13ugN65t1wvV";
  mojom::SolanaTxDataPtr system_transfer_data = nullptr;
  TestMakeSystemProgramTransferTxData(from, to, 10000000, nullptr,
                                      mojom::SolanaProviderError::kSuccess, "",
                                      &system_transfer_data);
  ASSERT_TRUE(system_transfer_data);

  SetInterceptor(latest_blockhash1_, last_valid_block_height1_, tx_hash1_,
                 kMockGetFeeForMessageResponse, true, last_valid_block_height1_,
                 "[null]");
  std::string meta_id1;
  AddUnapprovedTransaction(mojom::kSolanaMainnet, system_transfer_data.Clone(),
                           from, &meta_id1);
  ASSERT_FALSE(meta_id1.empty());

  send_transaction_calls_ = 0;
  ApproveTransaction(meta_id1);
  WaitForUpdatePendingTransactions();
  EXPECT_EQ(send_transaction_calls_, 1u);

  auto tx = solana_tx_manager()->GetTxForTesting(meta_id1);
  ASSERT_TRUE(tx);
  tx->set_submitted_time(base::Time::Now() - base::Minutes(30));
  ASSERT_TRUE(
      solana_tx_manager()->GetSolanaTxStateManager()->AddOrUpdateTx(*tx));

  send_transaction_calls_ = 0;
  SetInterceptor(latest_blockhash2_, last_valid_block_height2_, tx_hash1_, "",
                 true, last_valid_block_height1_, "[null]");
  task_environment_.FastForwardBy(
      base::Seconds(kSolanaBlockTrackerTimeInSeconds));
  WaitForUpdatePendingTransactions();

  EXPECT_EQ(send_transaction_calls_, 0u);
  tx = solana_tx_manager()->GetTxForTesting(meta_id1);
  ASSERT_TRUE(tx);
  EXPECT_EQ(tx->status(), mojom::TransactionStatus::Dropped);
}

TEST_F(SolanaTxManagerUnitTest, RetryTransaction) {
  // Add a transaction with blockhash.
  mojom::SolanaTxDataPtr tx_data =
      GetSystemProgramTransferTxData(sol_account(), to_account());
  ASSERT_TRUE(tx_data);
  tx_data->recent_blockhash = latest_blockhash1_;
  tx_data->last_valid_block_height = last_valid_block_height1_;
  std::string meta_id1;
  SetInterceptor(latest_blockhash1_, last_valid_block_height1_, tx_hash1_,
                 kMockGetFeeForMessageResponse, false,
                 last_valid_block_height1_);
  AddUnapprovedTransaction(mojom::kSolanaMainnet, std::move(tx_data),
                           sol_account(), &meta_id1);

  // Add a transaction with durable nonce.
  mojom::SolanaTxDataPtr durable_nonce_tx_data =
      GetSystemProgramTransferTxData(sol_account(), to_account());
  auto nonce_account = SolAccount(3);
  durable_nonce_tx_data->recent_blockhash = nonce_account->address;
  durable_nonce_tx_data->last_valid_block_height =
      last_valid_block_height1_ + kSolanaValidBlockHeightThreshold;
  std::string meta_id2;
  AddUnapprovedTransaction(mojom::kSolanaMainnet,
                           std::move(durable_nonce_tx_data), sol_account(),
                           &meta_id2);

  auto durable_nonce_meta = solana_tx_manager()->GetTxForTesting(meta_id2);
  ASSERT_TRUE(durable_nonce_meta);

  // Put AdvanceNonceAccount instruction before the transfer instruction.
  SolanaInstruction instruction = GetAdvanceNonceAccountInstruction();
  std::vector<SolanaInstruction> vec;
  vec.emplace_back(instruction);
  vec.emplace_back(durable_nonce_meta->tx()->message()->instructions()[0]);
  durable_nonce_meta->tx()->message()->SetInstructionsForTesting(vec);

  ASSERT_TRUE(solana_tx_manager()->GetSolanaTxStateManager()->AddOrUpdateTx(
      *durable_nonce_meta));

  // Test retry transaction with invalid state.
  TestRetryTransaction(
      FROM_HERE, meta_id1, false,
      l10n_util::GetStringUTF8(IDS_BRAVE_WALLET_TRANSACTION_NOT_RETRIABLE));

  // Update both transactions to dropped.
  auto tx_meta1 = solana_tx_manager()->GetTxForTesting(meta_id1);
  ASSERT_TRUE(tx_meta1);
  auto tx_meta2 = solana_tx_manager()->GetTxForTesting(meta_id2);
  ASSERT_TRUE(tx_meta2);
  tx_meta1->set_status(mojom::TransactionStatus::Dropped);
  tx_meta2->set_status(mojom::TransactionStatus::Dropped);
  ASSERT_TRUE(
      solana_tx_manager()->GetSolanaTxStateManager()->AddOrUpdateTx(*tx_meta1));
  ASSERT_TRUE(
      solana_tx_manager()->GetSolanaTxStateManager()->AddOrUpdateTx(*tx_meta2));

  TestRetryTransaction(FROM_HERE, meta_id1, true, "", "");
  TestRetryTransaction(FROM_HERE, meta_id2, true, "", nonce_account->address);

  // Test retry partial signed transaction, only the one using durable nonce
  // can be retried.
  tx_meta1 = solana_tx_manager()->GetTxForTesting(meta_id1);
  ASSERT_TRUE(tx_meta1);
  tx_meta2 = solana_tx_manager()->GetTxForTesting(meta_id2);
  ASSERT_TRUE(tx_meta2);

  auto param = mojom::SolanaSignTransactionParam::New(
      "test", std::vector<mojom::SignaturePubkeyPairPtr>());
  param->signatures.emplace_back(mojom::SignaturePubkeyPair::New(
      std::vector<uint8_t>(kSolanaSignatureSize, 1), sol_account()->address));
  tx_meta1->tx()->set_sign_tx_param(param.Clone());
  tx_meta2->tx()->set_sign_tx_param(param.Clone());

  ASSERT_TRUE(
      solana_tx_manager()->GetSolanaTxStateManager()->AddOrUpdateTx(*tx_meta1));
  ASSERT_TRUE(
      solana_tx_manager()->GetSolanaTxStateManager()->AddOrUpdateTx(*tx_meta2));
  TestRetryTransaction(
      FROM_HERE, meta_id1, false,
      l10n_util::GetStringUTF8(IDS_BRAVE_WALLET_TRANSACTION_NOT_RETRIABLE));
  TestRetryTransaction(FROM_HERE, meta_id2, true, "", nonce_account->address);

  // Test retry transaction with unknown tx id.
  TestRetryTransaction(
      FROM_HERE, "UnknownTxID", false,
      l10n_util::GetStringUTF8(IDS_BRAVE_WALLET_TRANSACTION_NOT_FOUND));

  // Test retry transaction with invalid tx type.
  tx_meta1->tx()->set_tx_type(mojom::TransactionType::SolanaSwap);
  ASSERT_TRUE(
      solana_tx_manager()->GetSolanaTxStateManager()->AddOrUpdateTx(*tx_meta1));
  TestRetryTransaction(
      FROM_HERE, meta_id1, false,
      l10n_util::GetStringUTF8(IDS_BRAVE_WALLET_TRANSACTION_NOT_RETRIABLE));
}

TEST_F(SolanaTxManagerUnitTest, GetTransactionMessageToSign) {
  // Unknown tx_meta_id yields null message
  TestGetTransactionMessageToSign("Unknown", std::nullopt);
  std::vector<mojom::HardwareWalletAccountPtr> hw_infos;
  hw_infos.push_back(mojom::HardwareWalletAccount::New(
      "89DzXVKJ79xf9MkzTxatQESh5fcvsqBo9fCsbAXkCaZE", "path", "name 1",
      "Ledger", "device1", mojom::CoinType::SOL, mojom::KeyringId::kSolana));
  auto from = keyring_service_->AddHardwareAccountsSync(std::move(hw_infos))[0]
                  ->account_id->Clone();
  const std::string to = "148FvZU6e67eSB12wv7fXCH5FsTDW8tsxXo3nFuZhfCF";
  mojom::SolanaTxDataPtr system_transfer_data = nullptr;
  TestMakeSystemProgramTransferTxData(from, to, 1, nullptr,
                                      mojom::SolanaProviderError::kSuccess, "",
                                      &system_transfer_data);
  ASSERT_TRUE(system_transfer_data);
  SetInterceptor(latest_blockhash1_, last_valid_block_height1_, tx_hash1_,
                 kMockGetFeeForMessageResponse, false,
                 last_valid_block_height1_);
  std::string system_transfer_meta_id;
  AddUnapprovedTransaction(mojom::kSolanaMainnet,
                           std::move(system_transfer_data), from,
                           &system_transfer_meta_id);
  ASSERT_FALSE(system_transfer_meta_id.empty());

  // Valid latest blockhash yields valid transaction message to sign
  SetInterceptor(latest_blockhash1_, last_valid_block_height1_, "");
  std::optional<std::vector<std::uint8_t>> message = base::Base64Decode(
      "AQACBGodJRVUDnxVZv71pBNy0DZ/"
      "ui6dv1N37VgGEA+"
      "aezhZAMzywrLOSju1o9VJQ5KaB2lsblgqvdjtkDFlmZHz4KQDBkZv5SEXMv/"
      "srbpyw5vnvIzlu8X3EmssQ5s6QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
      "AzEkOkozS44c7s0P8ldozF5ymD02/"
      "RsLDbpEpnVXU5rkDAgAFAtkpAQACAAkDZAAAAAAAAAADAgABDAIAAAABAAAAAAAAAA==");
  TestGetTransactionMessageToSign(system_transfer_meta_id, message);

  // Valid cached latest blockhash
  SetInterceptor("", 0, "", "");
  TestGetTransactionMessageToSign(system_transfer_meta_id, message);
}

TEST_F(SolanaTxManagerUnitTest, ProcessSolanaHardwareSignature) {
  // Unknown tx_meta_id is invalid
  TestProcessSolanaHardwareSignature(
      "Unknown", std::vector<uint8_t>(), false,
      mojom::SolanaProviderError::kInternalError,
      l10n_util::GetStringUTF8(IDS_BRAVE_WALLET_TRANSACTION_NOT_FOUND));

  std::vector<mojom::HardwareWalletAccountPtr> hw_infos;
  hw_infos.push_back(mojom::HardwareWalletAccount::New(
      "89DzXVKJ79xf9MkzTxatQESh5fcvsqBo9fCsbAXkCaZE", "path", "name 1",
      "Ledger", "device1", mojom::CoinType::SOL, mojom::KeyringId::kSolana));
  auto from = keyring_service_->AddHardwareAccountsSync(std::move(hw_infos))[0]
                  ->account_id.Clone();
  const std::string to = "148FvZU6e67eSB12wv7fXCH5FsTDW8tsxXo3nFuZhfCF";
  mojom::SolanaTxDataPtr system_transfer_data = nullptr;
  TestMakeSystemProgramTransferTxData(from, to, 1, nullptr,
                                      mojom::SolanaProviderError::kSuccess, "",
                                      &system_transfer_data);
  ASSERT_TRUE(system_transfer_data);
  SetInterceptor(latest_blockhash1_, last_valid_block_height1_, tx_hash1_,
                 kMockGetFeeForMessageResponse, false,
                 last_valid_block_height1_);
  std::string system_transfer_meta_id;
  AddUnapprovedTransaction(mojom::kSolanaMainnet,
                           std::move(system_transfer_data), from,
                           &system_transfer_meta_id);
  ASSERT_FALSE(system_transfer_meta_id.empty());

  std::string decoded_signature;
  std::string signature =
      "fJaHU9cDUoLsWLXJSPTgW3bAkhuZL319v2479igQtSp1ZyBjPi923jWkALg48uS75z5fp1JK"
      "1T4vdWi2D35fFEj";
  std::vector<uint8_t> signature_bytes;
  EXPECT_TRUE(Base58Decode(signature, &signature_bytes, kSolanaSignatureSize));

  auto meta = solana_tx_manager()->GetTxForTesting(system_transfer_meta_id);
  meta->tx()->message()->set_recent_blockhash(latest_blockhash1_);
  meta->tx()->message()->set_last_valid_block_height(last_valid_block_height1_);
  ASSERT_TRUE(
      solana_tx_manager()->GetSolanaTxStateManager()->AddOrUpdateTx(*meta));

  // Valid blockhash and valid number of signers is valid
  TestProcessSolanaHardwareSignature(system_transfer_meta_id, signature_bytes,
                                     true, mojom::SolanaProviderError::kSuccess,
                                     "");
}

TEST_F(SolanaTxManagerUnitTest, RebroadcastTransaction) {
  auto data = GetSystemProgramTransferTxData(sol_account(), to_account());
  ASSERT_TRUE(data);
  SetInterceptor(latest_blockhash1_, last_valid_block_height1_, "", "", true,
                 last_valid_block_height1_, "[null]");

  std::string meta_id1;
  SetInterceptor(latest_blockhash1_, last_valid_block_height1_, tx_hash1_,
                 kMockGetFeeForMessageResponse, false,
                 last_valid_block_height1_);
  AddUnapprovedTransaction(mojom::kSolanaMainnet, data.Clone(), sol_account(),
                           &meta_id1);
  ASSERT_FALSE(meta_id1.empty());

  // No rebroadcast when first sending out the tx.
  ApproveTransaction(meta_id1);
  WaitForUpdatePendingTransactions();
  EXPECT_EQ(send_transaction_calls_, 1u);

  // Rebradcast should happen once for tx with null signature status.
  send_transaction_calls_ = 0;
  SetInterceptor(latest_blockhash2_, last_valid_block_height2_, "", "", true,
                 last_valid_block_height1_, "[null]");
  task_environment_.FastForwardBy(
      base::Seconds(kSolanaBlockTrackerTimeInSeconds));
  WaitForUpdatePendingTransactions();
  EXPECT_EQ(send_transaction_calls_, 1u);

  // Rebroadcast should happen once when tx is not confirmed and latest
  // blockhash is updated which triggers UpdatePendingTransaction.
  send_transaction_calls_ = 0;
  SetInterceptor(latest_blockhash3_, last_valid_block_height3_, "", "", true,
                 last_valid_block_height1_,
                 R"([{"slot": 100, "confirmations": 100, "err": null,
                      "confirmationStatus": "processed"}])");

  task_environment_.FastForwardBy(
      base::Seconds(kSolanaBlockTrackerTimeInSeconds));
  WaitForUpdatePendingTransactions();
  EXPECT_EQ(send_transaction_calls_, 1u);

  // No rebroadcast when blockhash is expired.
  send_transaction_calls_ = 0;
  SetInterceptor(latest_blockhash1_, last_valid_block_height1_, "",
                 kMockGetFeeForMessageResponse, true, last_valid_block_height2_,
                 R"([{"slot": 100, "confirmations": 100, "err": null,
                      "confirmationStatus": "processed"}])");
  task_environment_.FastForwardBy(
      base::Seconds(kSolanaBlockTrackerTimeInSeconds));
  WaitForUpdatePendingTransactions();
  EXPECT_EQ(send_transaction_calls_, 0u);

  SetInterceptor(latest_blockhash2_, last_valid_block_height2_, "",
                 kMockGetFeeForMessageResponse, true, last_valid_block_height2_,
                 "[null, null]");
  data->send_options = mojom::SolanaSendTransactionOptions::New(
      mojom::OptionalMaxRetries::New(1u), std::nullopt, nullptr);
  std::string meta_id2;
  AddUnapprovedTransaction(mojom::kSolanaMainnet, data.Clone(), sol_account(),
                           &meta_id2);
  ASSERT_FALSE(meta_id2.empty());

  // Avoid cached blockhash being used when approve.
  task_environment_.FastForwardBy(
      base::Seconds(kSolanaBlockTrackerTimeInSeconds));
  WaitForUpdatePendingTransactions();

  // No rebroadcast when first sending out the tx with customized MaxRetries.
  send_transaction_calls_ = 0;
  ApproveTransaction(meta_id2);
  WaitForUpdatePendingTransactions();
  EXPECT_EQ(send_transaction_calls_, 1u);

  // Rebroadcast when tx signature status is null with customized MaxRetries.
  SetInterceptor(latest_blockhash3_, last_valid_block_height3_, "", "", true,
                 last_valid_block_height2_, "[null]");
  send_transaction_calls_ = 0;
  task_environment_.FastForwardBy(
      base::Seconds(kSolanaBlockTrackerTimeInSeconds));
  WaitForUpdatePendingTransactions();
  EXPECT_EQ(send_transaction_calls_, 1u);
}

TEST_F(SolanaTxManagerUnitTest, GetSolanaTxFeeEstimation) {
  // Fetching fee estimate for non existant tx id meta fails.
  TestGetSolanaTxFeeEstimation(
      mojom::kSolanaMainnet, "non existant tx meta id", {},
      mojom::SolanaProviderError::kInternalError,
      l10n_util::GetStringUTF8(IDS_BRAVE_WALLET_TRANSACTION_NOT_FOUND));

  // Add an unapproved tx manually (circumventing the fee estimation fetching
  // built into that function).
  const auto& from_account = sol_account();
  std::string from_account_address = from_account->address;

  std::string to_account = "JDqrvDz8d8tFCADashbUKQDKfJZFobNy13ugN65t1wvV";
  const std::vector<uint8_t> data = {2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0};

  std::vector<mojom::SolanaAccountMetaPtr> account_metas;
  auto account_meta1 =
      mojom::SolanaAccountMeta::New(from_account_address, nullptr, true, true);
  auto account_meta2 =
      mojom::SolanaAccountMeta::New(to_account, nullptr, false, true);
  account_metas.push_back(std::move(account_meta1));
  account_metas.push_back(std::move(account_meta2));

  auto instruction = mojom::SolanaInstruction::New(
      mojom::kSolanaSystemProgramId, std::move(account_metas), data, nullptr);
  std::vector<mojom::SolanaInstructionPtr> instructions;
  instructions.push_back(std::move(instruction));
  auto solana_tx_data = mojom::SolanaTxData::New(
      "", 0, from_account_address, to_account, "", 10000000, 0,
      mojom::TransactionType::SolanaSystemTransfer, std::move(instructions),
      mojom::SolanaMessageVersion::kLegacy,
      mojom::SolanaMessageHeader::New(1, 0, 1),
      std::vector<std::string>(
          {from_account_address, to_account, mojom::kSolanaSystemProgramId}),
      std::vector<mojom::SolanaMessageAddressTableLookupPtr>(), nullptr,
      nullptr, nullptr);

  auto tx = SolanaTransaction::FromSolanaTxData(solana_tx_data.Clone());
  ASSERT_TRUE(tx);

  SolanaTxMeta meta(from_account, std::move(tx));
  meta.set_id(TxMeta::GenerateMetaID());
  meta.set_created_time(base::Time::Now());
  meta.set_status(mojom::TransactionStatus::Unapproved);
  meta.set_chain_id(mojom::kSolanaMainnet);

  ASSERT_TRUE(
      solana_tx_manager()->GetSolanaTxStateManager()->AddOrUpdateTx(meta));
  task_environment_.RunUntilIdle();

  // Call fetch fee estimation with appropriate interceptors. Verify median and
  // priority fees.
  SetInterceptor(latest_blockhash1_, last_valid_block_height1_, tx_hash1_,
                 kMockGetFeeForMessageResponse, false,
                 last_valid_block_height1_);
  mojom::SolanaFeeEstimationPtr expected_estimate =
      mojom::SolanaFeeEstimation::New();
  expected_estimate->base_fee = 5000;
  expected_estimate->compute_units = 76249U;
  expected_estimate->fee_per_compute_unit = 100;
  TestGetSolanaTxFeeEstimation(mojom::kSolanaMainnet, meta.id(),
                               std::move(expected_estimate),
                               mojom::SolanaProviderError::kSuccess, "");
}

TEST_F(SolanaTxManagerUnitTest, MakeBubbleGumProgramTransferTxData) {
  // Invalid response JSON results in error
  std::map<GURL, std::string> responses;
  responses[GURL(
      "https://simplehash.wallet.brave.com/api/v0/nfts/proof/solana/"
      "2iZBbRGnLVEEZH6JDsaNsTo66s2uxx7DTchVWKU8oisR")] = "invalid json";
  SetInterceptors(responses);
  TestMakeBubbleGumProgramTransferTxData(
      mojom::kSolanaMainnet, "2iZBbRGnLVEEZH6JDsaNsTo66s2uxx7DTchVWKU8oisR",
      "FBG2vwk2tGKHbEWHSxf7rJGDuZ2eHaaNQ8u6c7xGt9Yv",
      "4szaz6FsfBzwcCJYjbwZWEw3E8rKB4tz76644C8sAZo9", nullptr,
      mojom::SolanaProviderError::kInternalError,
      l10n_util::GetStringUTF8(IDS_WALLET_INTERNAL_ERROR));

  // Valid response JSON results in valid tx data
  std::string json = R"({
    "root": "5bR96ZfMpkDCBQBFvNwdMRizNTp5ZcNEAYq6J3D7mXMR",
    "proof": [
      "ANs5srcJ9fSZpbGmJGXy8M6G3NeNABzK8SshSb9JCwAz",
      "7Kd9DCCFMFrezFznsWAqwA6jtmRRVVHjon5oKVJFffDf",
      "BvSxmwtVL5bx41gnKhpx2hTdYnXdJ1XfetwwHxQPC8Mn",
      "GEtJJVAYjv5mknVVVSjvLmy7BJeQWSdKhbTWdfqLHhpK",
      "VbqjLNCgxCE6Mm9WMTtBxNmthVHqs557AXRRTMhTr4t",
      "3obQ6KPFsC9QfM6g3ZtYC2RbHPfUKn4iBnDecfZoBhbG",
      "DTLQKdFQj8ywDktN1BqR6oe48XGyoSGzAzQgX9QWfnBk",
      "6zZokt6UsXMNEcXPYn3T2LfSaZN6DmZoDwqc3rM16ohu",
      "4aPfGxhmkgrh6Lz82dsi4mdcNC3vZyE1AXiYbJQta4Gw",
      "2AG8n5BwPATab9wWJ2g9XuqXS4xBiQvLVHhn1zX715Ub",
      "JAN9FwHcwqi79Um4MxzrBkTPYEtLHFkUFP8FbnPAFCzc",
      "Ha6247eWxRgGyFCN2NfLbkKMEpLwU1zmkx1QwwRxQ5Ne",
      "6Rt4B2UPizK2gdvmsd8KahazFtc8S5johvGZCUXmHGyV",
      "25wz52GHDo7vX9QSYbUwMd1gi82MUm8sdmAj5jFX8MAH",
      "5W1NH3cKSBdrKeXbd2t8QdwdTU4qTFpSrr1FZyVgHeS8",
      "2XTZ9pTcLXFxGw1hBGrzXMGJrMnvo47sGyLUQwF88SUb",
      "Sia7ffUkzN8xqRHLX4xRdFXzUbVv7LtzRzKDBz8hgDK",
      "4XjrBbzyUWXxXECf173MukGdjHDWQMJ7rs2ojny445my",
      "DqbTjtfiRPHZf2wwmMJ38acyJNTHeiYBsrySSjbMYNiE",
      "2msvGdBzYX2sHifvvr8kJ6YYYvCK2gjjbRZH2tAQ93d5",
      "2XvcBPNUGQSWmyjqYYk9WDFsKLF9oMrnAYxKBJGsPXtw",
      "HSURhkbUwDFSy464A5vNPuPaqe1vWb51YeAf689oprx8",
      "76hjrsKb9iKgHhiY2Np3NYPZaEwnzGcsr6mwyzj4Grj8",
      "6FMzwZu6MxNiBkrE9e6w5fwh925YJEJoRNyQQ9JnrJs3"
    ],
    "merkle_tree": "7eFJyb6UF4hQS7nSQaiy8Xpdq6V7Q1ZRjD3Lze11DZTd",
    "data_hash": "4yfgTevXs3x93pS8tfaqh92y22gAqcRS6Ptt8s6uR3u2",
    "creator_hash": "BSao3oE3zsHmciedhR95HTFyASwrMrwPkcA3xZH9iyzL",
    "leaf_index": 1316261,
    "owner": "FBG2vwk2tGKHbEWHSxf7rJGDuZ2eHaaNQ8u6c7xGt9Yv",
    "delegate": "6G9UfJJEgQpNB7rDWoVRHcF93nAShcFu7EwedYkua3PH",
    "canopy_depth": 0
  })";
  responses[GURL(
      "https://simplehash.wallet.brave.com/api/v0/nfts/proof/solana/"
      "2iZBbRGnLVEEZH6JDsaNsTo66s2uxx7DTchVWKU8oisR")] = json;
  // Invalid get account info response results in error
  responses[GURL("https://solana-mainnet.wallet.brave.com/")] = "invalid json";
  SetInterceptors(responses);
  TestMakeBubbleGumProgramTransferTxData(
      mojom::kSolanaMainnet, "2iZBbRGnLVEEZH6JDsaNsTo66s2uxx7DTchVWKU8oisR",
      "FBG2vwk2tGKHbEWHSxf7rJGDuZ2eHaaNQ8u6c7xGt9Yv",
      "4szaz6FsfBzwcCJYjbwZWEw3E8rKB4tz76644C8sAZo9", nullptr,
      mojom::SolanaProviderError::kInternalError,
      l10n_util::GetStringUTF8(IDS_WALLET_INTERNAL_ERROR));

  // Valid getAccounitInfo response results in valid tx data
  responses[GURL("https://solana-mainnet.wallet.brave.com/")] =
      base::ReplaceStringPlaceholders(
          R"({
    "jsonrpc": "2.0",
    "result": {
      "context": {
        "apiVersion": "1.17.31",
        "slot": 271614906
      },
      "value": {
        "data": [
          "$1",
          "base64"
        ],
        "executable": false,
        "lamports": 366986880,
        "owner": "cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK",
        "rentEpoch": 18446744073709551615,
        "space": 52600
      }
    },
    "id": 1
  })",
          {kMockMerkleTreeAccountInfo}, nullptr);

  SetInterceptors(responses);

  std::vector<mojom::SolanaAccountMetaPtr> account_metas;
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "2rm66D8wbJEfb9vNDuwmk5UhLj18h9ZURxVSRM13gzNL", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "FBG2vwk2tGKHbEWHSxf7rJGDuZ2eHaaNQ8u6c7xGt9Yv", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "FBG2vwk2tGKHbEWHSxf7rJGDuZ2eHaaNQ8u6c7xGt9Yv", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "4szaz6FsfBzwcCJYjbwZWEw3E8rKB4tz76644C8sAZo9", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "7eFJyb6UF4hQS7nSQaiy8Xpdq6V7Q1ZRjD3Lze11DZTd", nullptr, false, true));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "11111111111111111111111111111111", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "ANs5srcJ9fSZpbGmJGXy8M6G3NeNABzK8SshSb9JCwAz", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "7Kd9DCCFMFrezFznsWAqwA6jtmRRVVHjon5oKVJFffDf", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "BvSxmwtVL5bx41gnKhpx2hTdYnXdJ1XfetwwHxQPC8Mn", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "GEtJJVAYjv5mknVVVSjvLmy7BJeQWSdKhbTWdfqLHhpK", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "VbqjLNCgxCE6Mm9WMTtBxNmthVHqs557AXRRTMhTr4t", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "3obQ6KPFsC9QfM6g3ZtYC2RbHPfUKn4iBnDecfZoBhbG", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "DTLQKdFQj8ywDktN1BqR6oe48XGyoSGzAzQgX9QWfnBk", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "6zZokt6UsXMNEcXPYn3T2LfSaZN6DmZoDwqc3rM16ohu", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "4aPfGxhmkgrh6Lz82dsi4mdcNC3vZyE1AXiYbJQta4Gw", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "2AG8n5BwPATab9wWJ2g9XuqXS4xBiQvLVHhn1zX715Ub", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "JAN9FwHcwqi79Um4MxzrBkTPYEtLHFkUFP8FbnPAFCzc", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "Ha6247eWxRgGyFCN2NfLbkKMEpLwU1zmkx1QwwRxQ5Ne", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "6Rt4B2UPizK2gdvmsd8KahazFtc8S5johvGZCUXmHGyV", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "25wz52GHDo7vX9QSYbUwMd1gi82MUm8sdmAj5jFX8MAH", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "5W1NH3cKSBdrKeXbd2t8QdwdTU4qTFpSrr1FZyVgHeS8", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "2XTZ9pTcLXFxGw1hBGrzXMGJrMnvo47sGyLUQwF88SUb", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "Sia7ffUkzN8xqRHLX4xRdFXzUbVv7LtzRzKDBz8hgDK", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "4XjrBbzyUWXxXECf173MukGdjHDWQMJ7rs2ojny445my", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "DqbTjtfiRPHZf2wwmMJ38acyJNTHeiYBsrySSjbMYNiE", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "2msvGdBzYX2sHifvvr8kJ6YYYvCK2gjjbRZH2tAQ93d5", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "2XvcBPNUGQSWmyjqYYk9WDFsKLF9oMrnAYxKBJGsPXtw", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "HSURhkbUwDFSy464A5vNPuPaqe1vWb51YeAf689oprx8", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "76hjrsKb9iKgHhiY2Np3NYPZaEwnzGcsr6mwyzj4Grj8", nullptr, false, false));
  account_metas.push_back(mojom::SolanaAccountMeta::New(
      "6FMzwZu6MxNiBkrE9e6w5fwh925YJEJoRNyQQ9JnrJs3", nullptr, false, false));

  std::vector<uint8_t> data = {
      0xa3, 0x34, 0xc8, 0xe7, 0x8c, 0x03, 0x45, 0xba, 0x44, 0x3f, 0xca, 0x38,
      0xd1, 0x3e, 0x68, 0xf2, 0x95, 0xaf, 0xfc, 0x5f, 0x34, 0x31, 0xf3, 0x75,
      0xba, 0xd8, 0xd3, 0x82, 0x90, 0x1a, 0x94, 0x7f, 0x72, 0x96, 0xfc, 0xd8,
      0x79, 0x8a, 0xb7, 0x98, 0x3b, 0x17, 0x52, 0x74, 0x15, 0x6f, 0x94, 0x1a,
      0xe6, 0xc6, 0x1e, 0x0e, 0xb4, 0x6c, 0xcf, 0x64, 0xd6, 0x8f, 0xfd, 0x34,
      0xb7, 0x68, 0x6d, 0x97, 0x32, 0x45, 0x7e, 0x8a, 0x5c, 0x1a, 0x80, 0x31,
      0x9b, 0x22, 0x99, 0xb4, 0xc2, 0x20, 0x0e, 0x5e, 0xef, 0x2e, 0x12, 0xb1,
      0x6d, 0x4f, 0xbd, 0xf1, 0x2e, 0x11, 0xe1, 0x4f, 0xb2, 0x76, 0xc3, 0x91,
      0x21, 0x88, 0x34, 0xf3, 0x0a, 0xec, 0x39, 0x45, 0xa5, 0x15, 0x14, 0x00,
      0x00, 0x00, 0x00, 0x00, 0xa5, 0x15, 0x14, 0x00};
  auto solana_instruction = mojom::SolanaInstruction::New(
      mojom::kSolanaBubbleGumProgramId, std::move(account_metas),
      std::move(data), nullptr);

  std::vector<mojom::SolanaInstructionPtr> instructions;
  instructions.push_back(std::move(solana_instruction));

  mojom::SolanaTxDataPtr expected_tx_data = mojom::SolanaTxData::New(
      "", 0, "FBG2vwk2tGKHbEWHSxf7rJGDuZ2eHaaNQ8u6c7xGt9Yv",
      "4szaz6FsfBzwcCJYjbwZWEw3E8rKB4tz76644C8sAZo9", "", 0, 0,
      mojom::TransactionType::SolanaCompressedNftTransfer,
      std::move(instructions), mojom::SolanaMessageVersion::kLegacy,
      mojom::SolanaMessageHeader::New(1, 0, 30),
      std::vector<std::string>(
          {"FBG2vwk2tGKHbEWHSxf7rJGDuZ2eHaaNQ8u6c7xGt9Yv",
           "7eFJyb6UF4hQS7nSQaiy8Xpdq6V7Q1ZRjD3Lze11DZTd",
           "BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY",
           "2rm66D8wbJEfb9vNDuwmk5UhLj18h9ZURxVSRM13gzNL",
           "4szaz6FsfBzwcCJYjbwZWEw3E8rKB4tz76644C8sAZo9",
           "noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV",
           "cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK",
           "11111111111111111111111111111111",
           "ANs5srcJ9fSZpbGmJGXy8M6G3NeNABzK8SshSb9JCwAz",
           "7Kd9DCCFMFrezFznsWAqwA6jtmRRVVHjon5oKVJFffDf",
           "BvSxmwtVL5bx41gnKhpx2hTdYnXdJ1XfetwwHxQPC8Mn",
           "GEtJJVAYjv5mknVVVSjvLmy7BJeQWSdKhbTWdfqLHhpK",
           "VbqjLNCgxCE6Mm9WMTtBxNmthVHqs557AXRRTMhTr4t",
           "3obQ6KPFsC9QfM6g3ZtYC2RbHPfUKn4iBnDecfZoBhbG",
           "DTLQKdFQj8ywDktN1BqR6oe48XGyoSGzAzQgX9QWfnBk",
           "6zZokt6UsXMNEcXPYn3T2LfSaZN6DmZoDwqc3rM16ohu",
           "4aPfGxhmkgrh6Lz82dsi4mdcNC3vZyE1AXiYbJQta4Gw",
           "2AG8n5BwPATab9wWJ2g9XuqXS4xBiQvLVHhn1zX715Ub",
           "JAN9FwHcwqi79Um4MxzrBkTPYEtLHFkUFP8FbnPAFCzc",
           "Ha6247eWxRgGyFCN2NfLbkKMEpLwU1zmkx1QwwRxQ5Ne",
           "6Rt4B2UPizK2gdvmsd8KahazFtc8S5johvGZCUXmHGyV",
           "25wz52GHDo7vX9QSYbUwMd1gi82MUm8sdmAj5jFX8MAH",
           "5W1NH3cKSBdrKeXbd2t8QdwdTU4qTFpSrr1FZyVgHeS8",
           "2XTZ9pTcLXFxGw1hBGrzXMGJrMnvo47sGyLUQwF88SUb",
           "Sia7ffUkzN8xqRHLX4xRdFXzUbVv7LtzRzKDBz8hgDK",
           "4XjrBbzyUWXxXECf173MukGdjHDWQMJ7rs2ojny445my",
           "DqbTjtfiRPHZf2wwmMJ38acyJNTHeiYBsrySSjbMYNiE",
           "2msvGdBzYX2sHifvvr8kJ6YYYvCK2gjjbRZH2tAQ93d5",
           "2XvcBPNUGQSWmyjqYYk9WDFsKLF9oMrnAYxKBJGsPXtw",
           "HSURhkbUwDFSy464A5vNPuPaqe1vWb51YeAf689oprx8",
           "76hjrsKb9iKgHhiY2Np3NYPZaEwnzGcsr6mwyzj4Grj8",
           "6FMzwZu6MxNiBkrE9e6w5fwh925YJEJoRNyQQ9JnrJs3"}),
      std::vector<mojom::SolanaMessageAddressTableLookupPtr>(), nullptr,
      nullptr, nullptr);
  TestMakeBubbleGumProgramTransferTxData(
      mojom::kSolanaMainnet, "2iZBbRGnLVEEZH6JDsaNsTo66s2uxx7DTchVWKU8oisR",
      "FBG2vwk2tGKHbEWHSxf7rJGDuZ2eHaaNQ8u6c7xGt9Yv",
      "4szaz6FsfBzwcCJYjbwZWEw3E8rKB4tz76644C8sAZo9",
      std::move(expected_tx_data), mojom::SolanaProviderError::kSuccess, "");
}

TEST_F(SolanaTxManagerUnitTest, DecodeMerkleTreeAuthorityAndDepth) {
  const auto merkle_tree_account_info =
      base::Base64Decode(kMockMerkleTreeAccountInfo);
  ASSERT_TRUE(merkle_tree_account_info);

  auto result = solana_tx_manager()->DecodeMerkleTreeAuthorityAndDepth(
      *merkle_tree_account_info);
  ASSERT_TRUE(result);
  EXPECT_EQ((*result).second.ToBase58(),
            "2rm66D8wbJEfb9vNDuwmk5UhLj18h9ZURxVSRM13gzNL");
  EXPECT_EQ((*result).first, 0u);
}

}  // namespace brave_wallet
