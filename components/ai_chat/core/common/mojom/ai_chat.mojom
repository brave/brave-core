// Copyright (c) 2023 The Brave Authors. All rights reserved.
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// You can obtain one at https://mozilla.org/MPL/2.0/.

module ai_chat.mojom;

import "brave/components/ai_chat/core/common/mojom/common.mojom";
import "brave/components/ai_chat/core/common/mojom/untrusted_frame.mojom";
import "brave/components/ai_chat/core/common/mojom/tab_tracker.mojom";
import "mojo/public/mojom/base/time.mojom";
import "url/mojom/url.mojom";

// Share some tool names between the browser and the UI so that
// custom user actions and UI representations can be created.
// TODO(https://github.com/brave/brave-browser/issues/50097): move to
// untrusted_frame.mojom since these are only used in the conversation content
// frame.
const string kUserChoiceToolName = "user_choice_tool";
const string kAssistantDetailStorageToolName = "assistant_detail_storage";
const string kMemoryStorageToolName = "memory_storage_tool";
const string kClickToolName = "click_element";
const string kDragAndReleaseToolName = "drag_and_release";
const string kMoveMouseToolName = "move_mouse";
const string kNavigateToolName = "web_page_navigator";
const string kNavigateHistoryToolName = "navigate_history";
const string kScrollElementToolName = "scroll_element";
const string kSelectDropdownToolName = "select_dropdown";
const string kTypeTextToolName = "type_text";
const string kWaitToolName = "wait";


// Maximum length for memory and customization records.
const int32 kMaxMemoryRecordLength = 512;

// Full page screenshot filename prefix
const string kFullPageScreenshotPrefix = "fullscreenshot_";

// File upload limits
// https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Message.html#API_runtime_Message_Contents
const uint32 MAX_IMAGES = 20;
const uint32 MAX_DOCUMENTS = 5;
const uint32 MAX_DOCUMENT_SIZE_BYTES = 4718592; // 4.5MB


enum APIError {
  None,
  InternalError,
  ConnectionIssue,
  RateLimitReached,
  ContextLimitReached,
  InvalidEndpointURL,
  InvalidAPIKey,
  ServiceOverloaded
};


enum PremiumStatus {
  Unknown,
  Inactive,
  Active,
  ActiveDisconnected,
};

struct PremiumInfo {
  // How many credentials in the current batch are remaining
  uint32 remaining_credential_count;

  // When their next batch of credentials is active. If null, there is no
  // next batch.
  mojo_base.mojom.Time? next_active_at;
};

enum SuggestionGenerationStatus {
  None,
  CanGenerate,
  IsGenerating,
  HasGenerated,
};

struct Conversation {
  string uuid;
  // Set by the LLM or the user
  string title;

  // Time is used for ordering purposes.
  // This is not persisted - this is inferred from the
  // last updated time from the most recent
  // conversation entry.
  mojo_base.mojom.Time updated_time;

  // If there are entries and the conversation should be selectable.
  // This is not persisted - this is inferred from the entries.
  bool has_content;

  // Model key, if different than default
  string? model_key;
  // Indicates the total number of tokens for the conversation.
  // This info is determined by the server side and applies to the whole conversation.
  uint64 total_tokens;
  // Indicates the number of tokens that were trimmed from the conversation.
  // This info is determined by the server side and applies to the whole conversation.
  // Things that can be trimmed include associated content(s) and server side things like search results.
  uint64 trimmed_tokens;
  // Indicates whether the conversation is temporary which would be in-memory
  // only and not persisted in database.
  bool temporary = false;

  array<AssociatedContent> associated_content;
};

struct ContentArchive {
  string content_uuid;
  string content;

  // The turn this Content was sent with.
  string conversation_turn_uuid;
};

struct ConversationArchive {
  array<ConversationTurn> entries;
  array<ContentArchive> associated_content;
};

struct Skill {
  string id;
  string shortcut;
  string prompt;
  string? model;
  mojo_base.mojom.Time created_time;
  mojo_base.mojom.Time last_used;
};

struct ModelWithSubtitle {
  Model model;
  string subtitle;
};

struct ActionDetails {
  string label;
  ActionType type;
};

union ActionEntry {
  string subheading;
  ActionDetails details;
};

struct ActionGroup {
  string category;
  array<ActionEntry> entries;
};

// This does not cover more specific data that the Service owns, such as the
// conversation list, but does cover status of preferences and notices.
struct ServiceState {
  bool has_accepted_agreement;
  bool is_storage_pref_enabled;
  bool is_storage_notice_dismissed;
  bool can_show_premium_prompt;
};

interface Service {
  // Profile-level acknowledgements
  MarkAgreementAccepted();
  EnableStoragePref();
  DismissStorageNotice();
  DismissPremiumPrompt();

  // Skill management
  GetSkills() => (array<Skill> skills);
  CreateSkill(string shortcut, string prompt, string? model);
  UpdateSkill(string id, string shortcut, string prompt, string? model);
  DeleteSkill(string id);

  // Get metadata for conversations
  GetConversations() => (array<Conversation> conversations);

  // Get metadata for all quick actions
  GetActionMenuList() => (array<ActionGroup> action_list);

  // Current status of subscription
  GetPremiumStatus() => (PremiumStatus status, PremiumInfo? info);

  DeleteConversation(string id);
  RenameConversation(string id, string new_name);

  // Determines whether a conversation exists - we need this so we can determine
  // whether a URL is bogus (i.e. made up) or if it corresponds to a
  // not-visible-in-sidebar conversation.
  ConversationExists(string conversation_uuid) => (bool exists);

  // Bind ability to send events to the UI and receive current state
  BindObserver(pending_remote<ServiceObserver> ui) => (ServiceState state);

  // Bind specified Conversation for 2-way communication
  BindConversation(
      string conversation_uuid,
      pending_receiver<ConversationHandler> conversation,
      pending_remote<ConversationUI> conversation_ui);

  // Bind metrics interface
  BindMetrics(pending_receiver<Metrics> metrics);
};

interface ServiceObserver {
  OnConversationListChanged(array<Conversation> conversations);
  OnStateChanged(ServiceState state);
  OnSkillsChanged(array<Skill> skills);
};

// Browser-side handler for general AI Chat UI functions, implemented
// per-platform
interface AIChatUIHandler {
  // Open various external links or dialogs depending on the platform
  OpenAIChatSettings();

  // Open AI Chat memory management settings
  OpenMemorySettings();

  // From a sidebar or popup conversation, open the conversation in the
  // full-page UI.
  // TODO(petemill): WebUI Compile-timesupport for build flags
  // so that we can use [EnableIfNot=is_android] here.
  OpenConversationFullPage(string conversation_uuid);

  // Open the AIChat Agent profile
  OpenAIChatAgentProfile();

  OpenURL(url.mojom.Url url);
  OpenStorageSupportUrl();

  OpenModelSupportUrl();
  GoPremium();
  RefreshPremiumSession();
  ManagePremium();
  HandleVoiceRecognition(string conversation_uuid);
  ShowSoftKeyboard();
  // use_media_capture is used on Android only currently. It could
  // be used on desktop as well in the future when a camera support is added.
  UploadFile(bool use_media_capture)
      => (array<UploadedFile>? uploaded_files);

  // Process image files using backend processing (resizing and sanitization)
  ProcessImageFile(array<uint8> file_data, string filename)
      => (UploadedFile? processed_file);

  // Get a plural string for the given key and count.
  GetPluralString(string key, int32 count) => (string plural_string);

  // This might be a no-op if the UI isn't closeable
  CloseUI();

  // Provide a reference of the UI to the UI handler and get some
  // initial constant state
  SetChatUI(pending_remote<ChatUI> chat_ui) => (bool is_standalone);

  // Bind 2-way communication to the conversation related to the open page in
  // the current browser window. No binding will occur if this isn't a
  // tab-related UI, e.g. sidebar or popup.
  BindRelatedConversation(
      pending_receiver<ConversationHandler> conversation,
      pending_remote<ConversationUI> conversation_ui);

  // Associates an open tab with a conversation.
  AssociateTab(TabData tab, string conversation_uuid);

  // Associates content from a URL with a conversation.
  AssociateUrlContent(url.mojom.Url url, string title, string conversation_uuid);

  // Disassociates attached content from a conversation.
  DisassociateContent(AssociatedContent content, string conversation_uuid);

  // Make a completely new conversation, which may
  // be bound to the associated conversation, if this UI has a target
  NewConversation(pending_receiver<ConversationHandler> conversation,
      pending_remote<ConversationUI> conversation_ui);
};

// UI-side handler for messages from the browser WebUI
interface ChatUI {
  // Notifies that the default conversation for the
  // panel has changed. e.g. Tab navigation with AIChat open in sidebar.
  // Content ID is the content ID of the tab associated with the conversation,
  // if any.
  OnNewDefaultConversation(int32? content_id);
  OnChildFrameBound(pending_receiver<ParentUIFrame> receiver);
  // Notifies that files are selected between AIChatUIHandler::UploadFile() is
  // called and return of uploaded files after processed.
  OnUploadFilesSelected();
};

struct ConversationState {
  string conversation_uuid;
  bool is_request_in_progress;
  array<Model> all_models;
  string current_model_key;
  string default_model_key;
  array<string> suggested_questions;
  SuggestionGenerationStatus suggestion_status;
  array<AssociatedContent> associated_content;
  APIError error;
  // Indicates whether the conversation is temporary which would be in-memory
  // only and not persisted in database.
  bool temporary = false;
  // TODO(petemill): include conversation history, once
  // `OnConversationHistoryUpdate` is more intelligent (see TOOD in definition).
};

// Browser-side handler for a Conversation
interface ConversationHandler {
  GetState() => (ConversationState conversation_state);

  GetConversationUuid() => (string conversation_uuid);

  // Get all the possible models for any conversation
  // TODO(petemill): Move the models part to Service
  GetModels() => (array<Model> models, string current_model_key);

  // Command to change the model for the Conversation to |model_name|
  ChangeModel(string model_key);

  GetIsRequestInProgress() => (bool is_request_in_progress);

  // Get all visible history entries, including in-progress responses
  GetConversationHistory() => (array<ConversationTurn> conversation_history);

  // The browser should generate some questions and fire an event when they
  // are ready.
  GenerateQuestions();

  SubmitHumanConversationEntry(
      string input, array<UploadedFile>? uploaded_files);
  SubmitHumanConversationEntryWithAction(string input, ActionType action_type);
  SubmitHumanConversationEntryWithSkill(string input, string skill_id);
  SubmitSummarizationRequest();

  // Submit one of the generated suggested questions for response from
  // the assistant.
  SubmitSuggestion(string suggestion);

  // Get associated page information. If there is none then |associated_content|
  // will be empty.
  GetAssociatedContentInfo() => (
      array<AssociatedContent> associated_content);

  GetAPIResponseError() => (APIError error);
  RetryAPIRequest();

  // Reset the current error state and returns the
  // most recent message from the conversation to the caller.
  ClearErrorAndGetFailedMessage() => (ConversationTurn turn);

  // Stops a generation and if the last entry was a human entry returns it
  // to the caller.
  StopGenerationAndMaybeGetHumanEntry() => (ConversationTurn? human_entry);

  // Send a user-rating for a chat
  // message. |turn_id| is the index of the message in the
  // specified conversation.
  RateMessage(bool is_liked, string turn_uuid)
      => (string? rating_id);
  SendFeedback(
      string category,
      string feedback,
      string rating_id, bool send_hostname) => (bool is_success);

  GetScreenshots() => (array<UploadedFile>? screenshots);

  // Make it a temporary conversation, only available at the start of the
  // conversation. It would be a no-op if the conversation is not empty.
  SetTemporary(bool temporary);
};

interface ConversationUI {
  OnConversationHistoryUpdate(ConversationTurn? entry);
  OnAPIRequestInProgress(bool is_request_in_progress);
  OnAPIResponseError(APIError error);
  // Usually the model is changed from the UI client, but occassionally
  // it could be changed from the browser.
  // When the browser changes the model, it will also provide a new list
  // of models.
  OnModelDataChanged(string conversation_model_key,
                     string default_model_key,
                     array<Model> all_models);
  // Provides the full list of questions for the active tab in the page's
  // Browser window.
  OnSuggestedQuestionsChanged(
      array<string> questions, SuggestionGenerationStatus status);
  // Associated page information has changed. If there is none then |associated_content|
  // will be |null|.
  OnAssociatedContentInfoChanged(array<AssociatedContent> associated_content);
  OnConversationDeleted();
};

interface Metrics {
  // Notify metrics service that a full page prompt is being sent
  OnSendingPromptWithFullPage();

  // Notify metrics service if a quick action is being used
  OnQuickActionStatusChange(bool is_enabled);
};

[EnableIf=is_android]
interface IAPSubscription {
  GetPurchaseTokenOrderId() => (string token, string order_id);
  SetLinkStatus(int32 status);
};
