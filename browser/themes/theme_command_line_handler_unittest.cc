/* Copyright (c) 2025 The Brave Authors. All rights reserved.
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at https://mozilla.org/MPL/2.0/. */

#include "base/command_line.h"
#include "brave/browser/themes/brave_dark_mode_utils.h"
#include "brave/browser/ui/themes/switches.h"
#include "build/build_config.h"
#include "chrome/browser/themes/theme_service.h"
#include "chrome/browser/themes/theme_service_factory.h"
#include "chrome/browser/themes/theme_service_test_utils.h"
#include "chrome/test/base/testing_profile.h"
#include "content/public/test/browser_task_environment.h"
#include "testing/gtest/include/gtest/gtest.h"
#include "third_party/skia/include/core/SkColor.h"
#include "ui/base/mojom/themes.mojom.h"

namespace {

using namespace brave::themes::switches;

class ThemeCommandLineHandlerTest : public testing::Test {
 public:
  void SetUp() override {
    profile_ = std::make_unique<TestingProfile>();
    theme_service_ = ThemeServiceFactory::GetForProfile(profile_.get());
    command_line_ =
        std::make_unique<base::CommandLine>(base::CommandLine::NO_PROGRAM);
  }

 protected:
  content::BrowserTaskEnvironment task_environment_;
  std::unique_ptr<TestingProfile> profile_;
  raw_ptr<ThemeService> theme_service_ = nullptr;
  std::unique_ptr<base::CommandLine> command_line_;
};

TEST_F(ThemeCommandLineHandlerTest, ProcessUserColorSwitch) {
  command_line_->AppendSwitchASCII(kSetUserColor, "0,255,128");

  EXPECT_EQ(std::nullopt, theme_service_->GetUserColor());

  ProcessThemeCommandLineSwitchesForProfile(command_line_.get(),
                                            profile_.get());

  EXPECT_EQ(SkColorSetRGB(0, 255, 128), theme_service_->GetUserColor());
  EXPECT_EQ(ThemeService::kUserColorThemeID, theme_service_->GetThemeID());
}

TEST_F(ThemeCommandLineHandlerTest, ProcessColorSchemeSwitch) {
  command_line_->AppendSwitchASCII(kSetColorScheme, "dark");

  EXPECT_EQ(ThemeService::BrowserColorScheme::kSystem,
            theme_service_->GetBrowserColorScheme());

  ProcessThemeCommandLineSwitchesForProfile(command_line_.get(),
                                            profile_.get());

  EXPECT_EQ(ThemeService::BrowserColorScheme::kDark,
            theme_service_->GetBrowserColorScheme());
}

TEST_F(ThemeCommandLineHandlerTest, ProcessColorSchemeSwitchLight) {
  command_line_->AppendSwitchASCII(kSetColorScheme, "light");

  ProcessThemeCommandLineSwitchesForProfile(command_line_.get(),
                                            profile_.get());

  EXPECT_EQ(ThemeService::BrowserColorScheme::kLight,
            theme_service_->GetBrowserColorScheme());
}

TEST_F(ThemeCommandLineHandlerTest, ProcessColorSchemeSwitchSystem) {
  theme_service_->SetBrowserColorScheme(
      ThemeService::BrowserColorScheme::kDark);
  EXPECT_EQ(ThemeService::BrowserColorScheme::kDark,
            theme_service_->GetBrowserColorScheme());

  command_line_->AppendSwitchASCII(kSetColorScheme, "system");

  ProcessThemeCommandLineSwitchesForProfile(command_line_.get(),
                                            profile_.get());

  EXPECT_EQ(ThemeService::BrowserColorScheme::kSystem,
            theme_service_->GetBrowserColorScheme());
}

TEST_F(ThemeCommandLineHandlerTest, ProcessDefaultThemeSwitch) {
  theme_service_->BuildAutogeneratedThemeFromColor(SK_ColorBLUE);
  EXPECT_TRUE(theme_service_->UsingAutogeneratedTheme());

  command_line_->AppendSwitch(kSetDefaultTheme);

  ProcessBrowserWideThemeCommandLineSwitches(command_line_.get(),
                                             profile_.get());

  EXPECT_TRUE(theme_service_->UsingDefaultTheme());
  EXPECT_FALSE(theme_service_->UsingAutogeneratedTheme());
}

TEST_F(ThemeCommandLineHandlerTest, ProcessGrayscaleSwitch) {
  // Brave's theme service always returns true for grayscale
  EXPECT_TRUE(theme_service_->GetIsGrayscale());

  // kSetGrayscaleTheme is now a boolean flag - presence means true
  command_line_->AppendSwitch(kSetGrayscaleTheme);

  ProcessThemeCommandLineSwitchesForProfile(command_line_.get(),
                                            profile_.get());

  // Should still be true after processing
  EXPECT_TRUE(theme_service_->GetIsGrayscale());
}

TEST_F(ThemeCommandLineHandlerTest, ProcessGrayscaleSwitchAbsent) {
  // Brave's theme service always returns true for grayscale
  // Test when the switch is absent (no change expected)
  EXPECT_TRUE(theme_service_->GetIsGrayscale());

  // Don't add the switch - it should remain unchanged

  ProcessThemeCommandLineSwitchesForProfile(command_line_.get(),
                                            profile_.get());

  // Still returns true because Brave forces grayscale mode
  EXPECT_TRUE(theme_service_->GetIsGrayscale());
}

TEST_F(ThemeCommandLineHandlerTest, ProcessColorVariantSwitch) {
  command_line_->AppendSwitchASCII(kSetColorVariant, "tonal_spot");

  EXPECT_EQ(ui::mojom::BrowserColorVariant::kSystem,
            theme_service_->GetBrowserColorVariant());

  ProcessThemeCommandLineSwitchesForProfile(command_line_.get(),
                                            profile_.get());

  EXPECT_EQ(ui::mojom::BrowserColorVariant::kTonalSpot,
            theme_service_->GetBrowserColorVariant());
}

TEST_F(ThemeCommandLineHandlerTest, ProcessColorVariantSwitchNeutral) {
  command_line_->AppendSwitchASCII(kSetColorVariant, "neutral");

  ProcessThemeCommandLineSwitchesForProfile(command_line_.get(),
                                            profile_.get());

  EXPECT_EQ(ui::mojom::BrowserColorVariant::kNeutral,
            theme_service_->GetBrowserColorVariant());
}

TEST_F(ThemeCommandLineHandlerTest, ProcessColorVariantSwitchVibrant) {
  command_line_->AppendSwitchASCII(kSetColorVariant, "vibrant");

  ProcessThemeCommandLineSwitchesForProfile(command_line_.get(),
                                            profile_.get());

  EXPECT_EQ(ui::mojom::BrowserColorVariant::kVibrant,
            theme_service_->GetBrowserColorVariant());
}

TEST_F(ThemeCommandLineHandlerTest, ProcessColorVariantSwitchExpressive) {
  command_line_->AppendSwitchASCII(kSetColorVariant, "expressive");

  ProcessThemeCommandLineSwitchesForProfile(command_line_.get(),
                                            profile_.get());

  EXPECT_EQ(ui::mojom::BrowserColorVariant::kExpressive,
            theme_service_->GetBrowserColorVariant());
}

TEST_F(ThemeCommandLineHandlerTest, ProcessUserColorAndVariantTogether) {
  command_line_->AppendSwitchASCII(kSetUserColor, "255,100,50");
  command_line_->AppendSwitchASCII(kSetColorVariant, "vibrant");

  ProcessThemeCommandLineSwitchesForProfile(command_line_.get(),
                                            profile_.get());

  EXPECT_EQ(SkColorSetRGB(255, 100, 50), theme_service_->GetUserColor());
  EXPECT_EQ(ui::mojom::BrowserColorVariant::kVibrant,
            theme_service_->GetBrowserColorVariant());
  EXPECT_EQ(ThemeService::kUserColorThemeID, theme_service_->GetThemeID());
}

TEST_F(ThemeCommandLineHandlerTest, ProcessEmptyCommandLine) {
  EXPECT_TRUE(theme_service_->UsingDefaultTheme());

  ProcessThemeCommandLineSwitchesForProfile(command_line_.get(),
                                            profile_.get());

  EXPECT_TRUE(theme_service_->UsingDefaultTheme());
  EXPECT_FALSE(theme_service_->UsingAutogeneratedTheme());
}

TEST_F(ThemeCommandLineHandlerTest, ProcessInvalidUserColor) {
  // Test invalid RGB values
  command_line_->AppendSwitchASCII(kSetUserColor, "256,0,0");

  ProcessThemeCommandLineSwitchesForProfile(command_line_.get(),
                                            profile_.get());

  // Should not set color if values are out of range
  EXPECT_EQ(std::nullopt, theme_service_->GetUserColor());
}

TEST_F(ThemeCommandLineHandlerTest, ProcessMalformedUserColor) {
  // Test malformed RGB string
  command_line_->AppendSwitchASCII(kSetUserColor, "not-a-color");

  ProcessThemeCommandLineSwitchesForProfile(command_line_.get(),
                                            profile_.get());

  // Should not set color if string is malformed
  EXPECT_EQ(std::nullopt, theme_service_->GetUserColor());
}

TEST_F(ThemeCommandLineHandlerTest, ProcessInvalidColorScheme) {
  // Test invalid color scheme value
  command_line_->AppendSwitchASCII(kSetColorScheme, "invalid");

  ProcessThemeCommandLineSwitchesForProfile(command_line_.get(),
                                            profile_.get());

  // Should remain at default
  EXPECT_EQ(ThemeService::BrowserColorScheme::kSystem,
            theme_service_->GetBrowserColorScheme());
}

TEST_F(ThemeCommandLineHandlerTest, ProcessInvalidColorVariant) {
  // Test invalid color variant value
  command_line_->AppendSwitchASCII(kSetColorVariant, "invalid");

  ProcessThemeCommandLineSwitchesForProfile(command_line_.get(),
                                            profile_.get());

  // Should remain at default
  EXPECT_EQ(ui::mojom::BrowserColorVariant::kSystem,
            theme_service_->GetBrowserColorVariant());
}

TEST_F(ThemeCommandLineHandlerTest, DefaultThemeTakesPrecedence) {
  // Test that kSetDefaultTheme takes precedence over other switches
  command_line_->AppendSwitch(kSetDefaultTheme);
  command_line_->AppendSwitchASCII(kSetUserColor, "255,0,0");
  command_line_->AppendSwitchASCII(kSetColorScheme, "dark");

  // Process browser-wide switch first (kSetDefaultTheme)
  ProcessBrowserWideThemeCommandLineSwitches(command_line_.get(),
                                             profile_.get());

  // Don't process per-profile switches when default theme is set
  // In production, the per-profile function would check for kSetDefaultTheme
  // and return early, but since we moved it to browser-wide, we skip
  // per-profile here

  // Default theme should be set, other switches should not affect it
  EXPECT_TRUE(theme_service_->UsingDefaultTheme());
  EXPECT_EQ(std::nullopt, theme_service_->GetUserColor());
}

}  // namespace
