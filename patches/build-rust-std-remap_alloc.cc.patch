diff --git a/build/rust/std/remap_alloc.cc b/build/rust/std/remap_alloc.cc
index 1a9d226dc538230d677f5062bdc72e62f8506987..6d010b61873104f99dc5b39669af3b3d79dd6f6d 100644
--- a/build/rust/std/remap_alloc.cc
+++ b/build/rust/std/remap_alloc.cc
@@ -75,6 +75,16 @@ extern "C" {
 #define REMAP_ALLOC_ATTRIBUTES __attribute__((weak))
 #endif  // COMPONENT_BUILD
 
+// This must exist as the stdlib depends on it to prove that we know the
+// alloc shims below are unstable. In the future we may be required to replace
+// them with a #[global_allocator] crate (see file comment above for more).
+//
+// Marked as weak as when Rust drives linking it includes this symbol itself,
+// and we don't want a collision due to C++ being in the same link target, where
+// C++ causes us to explicitly link in the stdlib and this symbol here.
+[[maybe_unused]] __attribute__((
+    weak)) unsigned char __rust_no_alloc_shim_is_unstable;
+
 REMAP_ALLOC_ATTRIBUTES void* __rust_alloc(size_t size, size_t align) {
   // This mirrors kMaxSupportedAlignment from
   // base/allocator/partition_allocator/partition_alloc_constants.h.
