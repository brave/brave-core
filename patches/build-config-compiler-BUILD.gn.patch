diff --git a/build/config/compiler/BUILD.gn b/build/config/compiler/BUILD.gn
index ae742b0b85a506f550852e611471338bde0da390..bb72d65adcd5a063bba6c86420f6334a8538b7b6 100644
--- a/build/config/compiler/BUILD.gn
+++ b/build/config/compiler/BUILD.gn
@@ -1019,6 +1019,7 @@ config("compiler") {
   if (use_safe_libcxx) {
     defines += [ "_LIBCPP_ENABLE_ASSERTIONS=1" ]
   }
+  rustflags -= brave_remove_rustflags
 }
 
 # The BUILDCONFIG file sets this config on targets by default, which means when
@@ -1568,6 +1569,87 @@ config("compiler_arm") {
   }
 }
 
+# Rust and C++ both provide intrinsics for LLVM to call for math operations. We
+# want to use the C++ intrinsics, not the ones in the Rust compiler_builtins
+# library. The Rust symbols are marked as weak, so that they can be replaced by
+# the C++ symbols. This config ensures the C++ symbols exist and are strong in
+# order to cause that replacement to occur by explicitly linking in clang's
+# compiler-rt library.
+if ((is_win || is_linux) && current_cpu == "arm64") { config("compiler_builtins") {} } else {
+config("compiler_builtins") {
+  visibility = [ ":runtime_library" ]
+
+  _dir = ""
+  _libname = "builtins"
+  _prefix = "lib"
+  _suffix = ""
+  _ext = "a"
+  if (is_win) {
+    _dir = "windows"
+    _prefix = ""
+    _ext = "lib"
+    if (current_cpu == "x64") {
+      _suffix = "-x86_64"
+    } else if (current_cpu == "x86") {
+      _suffix = "-i386"
+    } else if (current_cpu == "arm64") {
+      _suffix = "-arm64"
+    } else {
+      assert(false)  # Unhandled cpu type
+    }
+  } else if (is_mac) {
+    _dir = "darwin"
+    _libname = "osx"
+  } else if (is_ios) {
+    import("//build/config/ios/config.gni")  # For `target_environment`
+
+    _dir = "darwin"
+    if (target_environment == "simulator") {
+      _libname = "iossim"
+    } else {
+      _libname = "ios"
+    }
+  } else if (is_linux || is_chromeos) {
+    if (current_cpu == "x64") {
+      _dir = "x86_64-unknown-linux-gnu"
+    } else if (current_cpu == "x86") {
+      _dir = "i386-unknown-linux-gnu"
+    } else if (current_cpu == "arm") {
+      _dir = "armv7-unknown-linux-gnueabihf"
+    } else {
+      assert(false)  # Unhandled cpu type
+    }
+  } else if (is_fuchsia) {
+    if (current_cpu == "x64") {
+      _dir = "x86_64-unknown-fuchsia"
+    } else if (current_cpu == "arm64") {
+      _dir = "aarch64-unknown-fuchsia"
+    } else {
+      assert(false)  # Unhandled cpu type
+    }
+  } else if (is_android) {
+    _dir = "linux"
+    if (current_cpu == "x64") {
+      _suffix = "-x86_64-android"
+    } else if (current_cpu == "x86") {
+      _suffix = "-i686-android"
+    } else if (current_cpu == "arm") {
+      _suffix = "-arm-android"
+    } else if (current_cpu == "arm64") {
+      _suffix = "-aarch64-android"
+    } else {
+      assert(false)  # Unhandled cpu type
+    }
+  } else {
+    assert(!toolchain_has_rust)  # Unhandled target platform
+  }
+
+  _clang_lib_dir = "$clang_base_path/lib/clang/$clang_version/lib"
+  _lib_file = "${_prefix}clang_rt.${_libname}${_suffix}.${_ext}"
+  libs = [ "$_clang_lib_dir/$_dir/$_lib_file" ]
+}
+}
+
 # runtime_library -------------------------------------------------------------
 #
 # Sets the runtime library and associated options.
@@ -1589,6 +1671,10 @@ config("runtime_library") {
     configs += [ "//build/config/c++:runtime_library" ]
   }
 
+  if (toolchain_has_rust) {
+    configs += [ ":compiler_builtins" ]
+  }
+
   # Rust and C++ both provide intrinsics for LLVM to call for math operations. We
   # want to use the C++ intrinsics, not the ones in the Rust compiler_builtins
   # library. The Rust symbols are marked as weak, so that they can be replaced by
@@ -2570,7 +2656,7 @@ config("symbols") {
       if (use_dwarf5) {
         cflags += [ "-gdwarf-5" ]
         rustflags += [ "-Zdwarf-version=5" ]
-      } else if (!is_apple) {
+      } else {
         # Recent clang versions default to DWARF5 on Linux, and Android is about
         # to switch. TODO: Adopt that in controlled way.
         # Apple platforms still default to 4, so the flag is not needed there.
