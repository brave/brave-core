diff --git a/third_party/rust/serde_json_lenient/v0_2/wrapper/visitor.rs b/third_party/rust/serde_json_lenient/v0_2/wrapper/visitor.rs
index c8f0c444c21fa229d9b87bcb26fb8390d6a025ac..a0960386a025643ebc6b3d24b4398c1580a750a3 100644
--- a/third_party/rust/serde_json_lenient/v0_2/wrapper/visitor.rs
+++ b/third_party/rust/serde_json_lenient/v0_2/wrapper/visitor.rs
@@ -74,15 +74,17 @@ impl<'de> DeserializeSeed<'de> for CowStrVisitor {
 pub struct ValueVisitor<'c, 'k> {
     aggregate: DeserializationTarget<'c, 'k>,
     recursion_depth_check: RecursionDepthCheck,
+    allow_64bit_numbers: bool,
 }
 
 impl<'c, 'k> ValueVisitor<'c, 'k> {
-    pub fn new(target: DeserializationTarget<'c, 'k>, max_depth: usize) -> Self {
+    pub fn new(target: DeserializationTarget<'c, 'k>, max_depth: usize, allow_64bit_numbers: bool) -> Self {
         Self {
             aggregate: target,
             // The `max_depth` includes the top level of the JSON input, which is where parsing
             // starts. We subtract 1 to count the top level now.
             recursion_depth_check: RecursionDepthCheck(max_depth - 1),
+            allow_64bit_numbers: allow_64bit_numbers,
         }
     }
 }
@@ -121,7 +123,22 @@ impl<'de> Visitor<'de> for ValueVisitor<'_, '_> {
         // JSONReaderTest.LargerIntIsLossy for a related test.
         match i32::try_from(value) {
             Ok(value) => self.visit_i32(value),
-            Err(_) => self.visit_f64(value as f64),
+            Err(_) => if !self.allow_64bit_numbers {
+                self.visit_f64(value as f64)
+            } else {
+                #[cfg(feature = "large_integers")]
+                {
+                    match self.aggregate {
+                        DeserializationTarget::List { ctx } => ffi::list_append_i64(ctx, value),
+                        DeserializationTarget::Dict { ctx, key } => ffi::dict_set_i64(ctx, key, value),
+                    }
+                    Ok(())
+                }
+                #[cfg(not(feature = "large_integers"))]
+                {
+                    unreachable!("visit_i64 with allow_64bit_numbers should not be called without the 'large_integers' feature");
+                }
+            }
         }
     }
 
@@ -129,7 +146,22 @@ impl<'de> Visitor<'de> for ValueVisitor<'_, '_> {
         // See visit_i64 comment.
         match i32::try_from(value) {
             Ok(value) => self.visit_i32(value),
-            Err(_) => self.visit_f64(value as f64),
+            Err(_) => if !self.allow_64bit_numbers {
+                self.visit_f64(value as f64)
+            } else {
+                #[cfg(feature = "large_integers")]
+                {
+                    match self.aggregate {
+                        DeserializationTarget::List { ctx } => ffi::list_append_u64(ctx, value),
+                        DeserializationTarget::Dict { ctx, key } => ffi::dict_set_u64(ctx, key, value),
+                    }
+                    Ok(())
+                }
+                #[cfg(not(feature = "large_integers"))]
+                {
+                    unreachable!("visit_u64 with allow_64bit_numbers should not be called without the 'large_integers' feature");
+                }
+            }
         }
     }
 
@@ -175,6 +207,7 @@ impl<'de> Visitor<'de> for ValueVisitor<'_, '_> {
             access.next_value_seed(ValueVisitor {
                 aggregate: DeserializationTarget::Dict { ctx: inner_ctx.as_mut(), key },
                 recursion_depth_check: self.recursion_depth_check.recurse()?,
+                allow_64bit_numbers: self.allow_64bit_numbers,
             })?;
         }
         Ok(())
@@ -193,6 +226,7 @@ impl<'de> Visitor<'de> for ValueVisitor<'_, '_> {
         while let Some(_) = access.next_element_seed(ValueVisitor {
             aggregate: DeserializationTarget::List { ctx: inner_ctx.as_mut() },
             recursion_depth_check: self.recursion_depth_check.recurse()?,
+            allow_64bit_numbers: self.allow_64bit_numbers,
         })? {}
         Ok(())
     }
