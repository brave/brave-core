diff --git a/chrome/installer/util/google_update_settings_unittest.cc b/chrome/installer/util/google_update_settings_unittest.cc
index 64cc1564eb4ed659cf3fc323d4ea43bb597b76b5..7469d83d376ecd949ca64cae8b12440e913cdd79 100644
--- a/chrome/installer/util/google_update_settings_unittest.cc
+++ b/chrome/installer/util/google_update_settings_unittest.cc
@@ -173,41 +173,74 @@ class GoogleUpdateSettingsTest : public testing::Test {
 
 }  // namespace
 
-// Run through all combinations success and failure results, and a fistful
-// of initial "ap" values checking that the expected final "ap" value is
-// generated by GoogleUpdateSettings::UpdateGoogleUpdateApKey.
+// Run through all combinations of diff vs. full install, success and failure
+// results, and a fistful of initial "ap" values checking that the expected
+// final "ap" value is generated by
+// GoogleUpdateSettings::UpdateGoogleUpdateApKey.
 TEST_F(GoogleUpdateSettingsTest, UpdateGoogleUpdateApKey) {
+  const installer::ArchiveType archive_types[] = {
+      installer::UNKNOWN_ARCHIVE_TYPE, installer::FULL_ARCHIVE_TYPE,
+      installer::INCREMENTAL_ARCHIVE_TYPE};
   const int results[] = {installer::FIRST_INSTALL_SUCCESS,
                          installer::INSTALL_FAILED};
   const wchar_t* const plain[] = {L"", L"1.1", L"1.1-dev"};
   const wchar_t* const full[] = {L"-full", L"1.1-full", L"1.1-dev-full"};
   static_assert(std::size(full) == std::size(plain), "bad full array size");
   const wchar_t* const* input_arrays[] = {plain, full};
-  for (const int result : results) {
-    SCOPED_TRACE(
-        ::testing::Message()
-        << "result="
-        << (result == installer::FIRST_INSTALL_SUCCESS ? "SUCCESS" : "FAILED"));
-    const wchar_t* const* outputs = plain;
-
-    for (const wchar_t* const* inputs : input_arrays) {
-      for (size_t input_idx = 0; input_idx < std::size(plain); ++input_idx) {
-        const wchar_t* input = inputs[input_idx];
-        const wchar_t* output = outputs[input_idx];
-        SCOPED_TRACE(::testing::Message() << "input=\"" << input << "\"");
-        SCOPED_TRACE(::testing::Message() << "output=\"" << output << "\"");
-
-        std::unique_ptr<WorkItemList> work_item_list(
-            WorkItem::CreateWorkItemList());
-
-        ASSERT_TRUE(CreateApKey(work_item_list.get(), input));
-        installer::AdditionalParameters ap;
-        if (std::wstring_view(output) == ap.value()) {
-          EXPECT_FALSE(GoogleUpdateSettings::UpdateGoogleUpdateApKey(ap));
-        } else {
-          EXPECT_TRUE(GoogleUpdateSettings::UpdateGoogleUpdateApKey(ap));
+  for (const installer::ArchiveType archive_type : archive_types) {
+    SCOPED_TRACE(::testing::Message()
+                 << "archive_type="
+                 << (archive_type == installer::UNKNOWN_ARCHIVE_TYPE
+                         ? "UNKNOWN"
+                         : (archive_type == installer::FULL_ARCHIVE_TYPE
+                                ? "FULL"
+                                : "INCREMENTAL")));
+    for (const int result : results) {
+      SCOPED_TRACE(::testing::Message()
+                   << "result="
+                   << (result == installer::FIRST_INSTALL_SUCCESS ? "SUCCESS"
+                                                                  : "FAILED"));
+      // The archive type will/must always be known on install success.
+      if (archive_type == installer::UNKNOWN_ARCHIVE_TYPE &&
+          result == installer::FIRST_INSTALL_SUCCESS) {
+        continue;
+      }
+      const wchar_t* const* outputs = nullptr;
+      if (result == installer::FIRST_INSTALL_SUCCESS ||
+          archive_type == installer::FULL_ARCHIVE_TYPE) {
+        outputs = plain;
+      } else if (archive_type == installer::INCREMENTAL_ARCHIVE_TYPE) {
+        outputs = full;
+      }  // else if (archive_type == UNKNOWN) see below
+
+      for (const wchar_t* const* inputs : input_arrays) {
+        if (archive_type == installer::UNKNOWN_ARCHIVE_TYPE) {
+          // "-full" is untouched if the archive type is unknown.
+          if (inputs == full)
+            outputs = full;
+          else
+            outputs = plain;
+        }
+        for (size_t input_idx = 0; input_idx < std::size(plain); ++input_idx) {
+          const wchar_t* input = inputs[input_idx];
+          const wchar_t* output = outputs[input_idx];
+          SCOPED_TRACE(::testing::Message() << "input=\"" << input << "\"");
+          SCOPED_TRACE(::testing::Message() << "output=\"" << output << "\"");
+
+          std::unique_ptr<WorkItemList> work_item_list(
+              WorkItem::CreateWorkItemList());
+
+          ASSERT_TRUE(CreateApKey(work_item_list.get(), input));
+          installer::AdditionalParameters ap;
+          if (std::wstring_view(output) == ap.value()) {
+            EXPECT_FALSE(GoogleUpdateSettings::UpdateGoogleUpdateApKey(
+                archive_type, result, &ap));
+          } else {
+            EXPECT_TRUE(GoogleUpdateSettings::UpdateGoogleUpdateApKey(
+                archive_type, result, &ap));
+          }
+          EXPECT_STREQ(output, ap.value());
         }
-        EXPECT_STREQ(output, ap.value());
       }
     }
   }
@@ -215,9 +248,39 @@ TEST_F(GoogleUpdateSettingsTest, UpdateGoogleUpdateApKey) {
 
 TEST_F(GoogleUpdateSettingsTest, UpdateInstallStatusTest) {
   std::unique_ptr<WorkItemList> work_item_list(WorkItem::CreateWorkItemList());
+  // Test incremental install failure
+  ASSERT_TRUE(CreateApKey(work_item_list.get(), L""))
+      << "Failed to create ap key.";
+  GoogleUpdateSettings::UpdateInstallStatus(
+      false, installer::INCREMENTAL_ARCHIVE_TYPE, installer::INSTALL_FAILED);
+  EXPECT_STREQ(ReadApKeyValue().c_str(), L"-full");
+  work_item_list->Rollback();
+
+  work_item_list.reset(WorkItem::CreateWorkItemList());
+  // Test incremental install success
+  ASSERT_TRUE(CreateApKey(work_item_list.get(), L""))
+      << "Failed to create ap key.";
+  GoogleUpdateSettings::UpdateInstallStatus(false,
+                                            installer::INCREMENTAL_ARCHIVE_TYPE,
+                                            installer::FIRST_INSTALL_SUCCESS);
+  EXPECT_STREQ(ReadApKeyValue().c_str(), L"");
+  work_item_list->Rollback();
+
+  work_item_list.reset(WorkItem::CreateWorkItemList());
+  // Test full install failure
+  ASSERT_TRUE(CreateApKey(work_item_list.get(), L"-full"))
+      << "Failed to create ap key.";
+  GoogleUpdateSettings::UpdateInstallStatus(false, installer::FULL_ARCHIVE_TYPE,
+                                            installer::INSTALL_FAILED);
+  EXPECT_STREQ(ReadApKeyValue().c_str(), L"");
+  work_item_list->Rollback();
+
+  work_item_list.reset(WorkItem::CreateWorkItemList());
+  // Test full install success
   ASSERT_TRUE(CreateApKey(work_item_list.get(), L"-full"))
       << "Failed to create ap key.";
-  GoogleUpdateSettings::UpdateInstallStatus();
+  GoogleUpdateSettings::UpdateInstallStatus(false, installer::FULL_ARCHIVE_TYPE,
+                                            installer::FIRST_INSTALL_SUCCESS);
   EXPECT_STREQ(ReadApKeyValue().c_str(), L"");
   work_item_list->Rollback();
 
@@ -235,9 +298,17 @@ TEST_F(GoogleUpdateSettingsTest, UpdateInstallStatusTest) {
   } else if (key.DeleteValue(google_update::kRegApField) == ERROR_SUCCESS) {
     ap_key_deleted = true;
   }
-  GoogleUpdateSettings::UpdateInstallStatus();
+  // try differential installer
+  GoogleUpdateSettings::UpdateInstallStatus(
+      false, installer::INCREMENTAL_ARCHIVE_TYPE, installer::INSTALL_FAILED);
+  EXPECT_STREQ(ReadApKeyValue().c_str(), L"-full");
+  // try full installer now
+  GoogleUpdateSettings::UpdateInstallStatus(false, installer::FULL_ARCHIVE_TYPE,
+                                            installer::INSTALL_FAILED);
   EXPECT_STREQ(ReadApKeyValue().c_str(), L"");
   // Now cleanup to leave the system in unchanged state.
+  // - Diff installer creates an ap key if it didn't exist, so delete this ap
+  // key
   // - If we created any reg key path for ap, roll it back
   // - Finally restore the original value of ap key.
   if (key.Open(HKEY_CURRENT_USER, reg_key.c_str(),
