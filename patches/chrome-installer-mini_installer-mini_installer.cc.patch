diff --git a/chrome/installer/mini_installer/mini_installer.cc b/chrome/installer/mini_installer/mini_installer.cc
index 44f29f2fafda83685479c791da3aa4ddbd4cde73..9aaf5989790538f38516f3e877aeb7fdfc03fdb5 100644
--- a/chrome/installer/mini_installer/mini_installer.cc
+++ b/chrome/installer/mini_installer/mini_installer.cc
@@ -149,8 +149,91 @@ void WriteExtraCode1(const Configuration& configuration, DWORD extra_code_1) {
   }
 }
 
+// This function sets the flag in registry to indicate that Google Update
+// should try full installer next time. If the current installer works, this
+// flag is cleared by setup.exe at the end of install.
+void SetInstallerFlags(const Configuration& configuration) {
+  StackString<128> value;
+
+  RegKey key;
+  if (!OpenInstallStateKey(configuration, &key)) {
+    return;
+  }
+
+  // TODO(grt): Trim legacy modifiers (chrome,chromeframe,apphost,applauncher,
+  // multi,readymode,stage,migrating,multifail) from the ap value.
+
+  LONG ret = key.ReadSZValue(kApRegistryValue, value.get(), value.capacity());
+
+  // The conditions below are handling two cases:
+  // 1. When ap value is present, we want to add the required tag only if it
+  //    is not present.
+  // 2. When ap value is missing, we are going to create it with the required
+  //    tag.
+  if ((ret == ERROR_SUCCESS) || (ret == ERROR_FILE_NOT_FOUND)) {
+    if (ret == ERROR_FILE_NOT_FOUND) {
+      value.clear();
+    }
+
+    if (!StrEndsWith(value.get(), kFullInstallerSuffix) &&
+        value.append(kFullInstallerSuffix)) {
+      key.WriteSZValue(kApRegistryValue, value.get());
+    }
+  }
+}
 #endif  // BUILDFLAG(GOOGLE_CHROME_BRANDING)
 
+// Gets the setup.exe path from Registry by looking at the value of Uninstall
+// string.  |size| is measured in wchar_t units.
+ProcessExitResult GetSetupExePathForAppGuid(bool system_level,
+                                            const wchar_t* app_guid,
+                                            const wchar_t* previous_version,
+                                            wchar_t* path,
+                                            size_t size) {
+  const HKEY root_key = system_level ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER;
+  RegKey key;
+  LONG result = OpenClientStateKey(root_key, app_guid, KEY_QUERY_VALUE, &key);
+  if (result == ERROR_SUCCESS) {
+    result = key.ReadSZValue(kUninstallRegistryValue, path, size);
+  }
+  if (result != ERROR_SUCCESS) {
+    return ProcessExitResult(UNABLE_TO_FIND_REGISTRY_KEY, result);
+  }
+
+  // Check that the path to the existing installer includes the expected
+  // version number.  It's not necessary for accuracy to verify before/after
+  // delimiters.
+  if (!SearchStringI(path, previous_version)) {
+    return ProcessExitResult(PATCH_NOT_FOR_INSTALLED_VERSION);
+  }
+
+  // Strip double-quotes surrounding the string, if present.
+  if (size >= 1 && path[0] == '\"') {
+    size_t path_length = SafeStrLen(path, size);
+    if (path_length >= 2 && path[path_length - 1] == '\"') {
+      if (!SafeStrCopy(path, size, path + 1)) {
+        return ProcessExitResult(PATH_STRING_OVERFLOW);
+      }
+      path[path_length - 2] = '\0';
+    }
+  }
+
+  return ProcessExitResult(SUCCESS_EXIT_CODE);
+}
+
+// Gets the path to setup.exe of the previous version. The overall path is found
+// in the Uninstall string in the registry. A previous version number specified
+// in |configuration| is used if available. |size| is measured in wchar_t units.
+ProcessExitResult GetPreviousSetupExePath(const Configuration& configuration,
+                                          wchar_t* path,
+                                          size_t size) {
+  // Check Chrome's ClientState key for the path to setup.exe. This will have
+  // the correct path for all well-functioning installs.
+  return GetSetupExePathForAppGuid(
+      configuration.is_system_level(), configuration.chrome_app_guid(),
+      configuration.previous_version(), path, size);
+}
+
 // Calls CreateProcess with good default parameters and waits for the process to
 // terminate returning the process exit code. In case of CreateProcess failure,
 // returns a results object with the provided codes as follows:
@@ -353,16 +436,56 @@ bool ResourceDeleterDelegate::OnResource(const wchar_t* name,
 }
 #endif  // defined(COMPONENT_BUILD)
 
+// Applies an differential update to the previous setup.exe provided by
+// `patch_path` and produces a new setup.exe at the path `target_path`.
+ProcessExitResult PatchSetup(const Configuration& configuration,
+                             const PathString& patch_path,
+                             const PathString& dest_path,
+                             int& max_delete_attempts) {
+  CommandString cmd_line;
+  PathString exe_path;
+  ProcessExitResult exit_code = GetPreviousSetupExePath(
+      configuration, exe_path.get(), exe_path.capacity());
+  if (!exit_code.IsSuccess()) {
+    return exit_code;
+  }
+
+  if (!cmd_line.append(L"\"") || !cmd_line.append(exe_path.get()) ||
+      !cmd_line.append(L"\" --") || !cmd_line.append(kCmdUpdateSetupExe) ||
+      !cmd_line.append(L"=\"") || !cmd_line.append(patch_path.get()) ||
+      !cmd_line.append(L"\" --") || !cmd_line.append(kCmdNewSetupExe) ||
+      !cmd_line.append(L"=\"") || !cmd_line.append(dest_path.get()) ||
+      !cmd_line.append(L"\"")) {
+    exit_code = ProcessExitResult(COMMAND_STRING_OVERFLOW);
+  }
+
+  if (!exit_code.IsSuccess()) {
+    return exit_code;
+  }
+
+  // Get any command line option specified for mini_installer and pass them
+  // on to setup.exe.
+  AppendCommandLineFlags(configuration.command_line(), &cmd_line);
+
+  exit_code = RunProcessAndWait(exe_path.get(), cmd_line.get(),
+                                SETUP_PATCH_FAILED_FILE_NOT_FOUND,
+                                SETUP_PATCH_FAILED_PATH_NOT_FOUND,
+                                SETUP_PATCH_FAILED_COULD_NOT_CREATE_PROCESS);
+  DeleteWithRetryAndMetrics(patch_path.get(), max_delete_attempts);
+
+  return exit_code;
+}
+
 }  // namespace
 
 ProcessExitResult UnpackBinaryResources(HMODULE module,
                                         const wchar_t* base_path,
                                         PathString& setup_path,
+                                        ResourceTypeString& setup_type,
                                         PathString& archive_path,
                                         ResourceTypeString& archive_type,
                                         int& max_delete_attempts) {
-  // Generate the setup.exe path where we uncompress setup resource.
-  ResourceTypeString setup_type;
+  // Generate the setup.exe path where we patch/uncompress setup resource.
   PathString setup_name;
   MemoryRange setup_range;
   PathString archive_name;
@@ -370,7 +493,8 @@ ProcessExitResult UnpackBinaryResources(HMODULE module,
 
   // Scan through all types of resources looking for the chrome archive (which
   // is expected to be either a B7 chrome.packed.7z or a BN chrome.7z) and
-  // installer (which is expected to be a BL setup.ex_, or a BN setup.exe).
+  // installer (which is expected to be a B7 setup_patch.packed.7z, a BL
+  // setup.ex_, or a BN setup.exe).
   for (const auto* type :
        {kLZMAResourceType, kLZCResourceType, kBinResourceType}) {
     DWORD error_code = ERROR_SUCCESS;
@@ -472,8 +596,17 @@ ProcessExitResult RunSetup(const Configuration& configuration,
                            bool compressed_archive) {
   // Get the path to setup.exe.
   PathString setup_exe;
-  if (!setup_exe.assign(setup_path)) {
-    return ProcessExitResult(COMMAND_STRING_OVERFLOW);
+
+  if (*setup_path != L'\0') {
+    if (!setup_exe.assign(setup_path)) {
+      return ProcessExitResult(COMMAND_STRING_OVERFLOW);
+    }
+  } else {
+    ProcessExitResult exit_code = GetPreviousSetupExePath(
+        configuration, setup_exe.get(), setup_exe.capacity());
+    if (!exit_code.IsSuccess()) {
+      return exit_code;
+    }
   }
 
   // There could be three full paths in the command line for setup.exe (path
@@ -495,10 +628,20 @@ ProcessExitResult RunSetup(const Configuration& configuration,
     return ProcessExitResult(COMMAND_STRING_OVERFLOW);
   }
 
+  // Append the command line param for the previous version of Chrome.
+  if (configuration.previous_version() &&
+      (!cmd_line.append(L" --") || !cmd_line.append(kCmdPreviousVersion) ||
+       !cmd_line.append(L"=\"") ||
+       !cmd_line.append(configuration.previous_version()) ||
+       !cmd_line.append(L"\""))) {
+    return ProcessExitResult(COMMAND_STRING_OVERFLOW);
+  }
+
   // Get any command line option specified for mini_installer and pass them
   // on to setup.exe
   AppendCommandLineFlags(configuration.command_line(), &cmd_line);
 
+  BRAVE_RUN_SETUP
   return RunProcessAndWait(setup_exe.get(), cmd_line.get(),
                            RUN_SETUP_FAILED_FILE_NOT_FOUND,
                            RUN_SETUP_FAILED_PATH_NOT_FOUND,
@@ -714,7 +857,7 @@ ProcessExitResult WMain(HMODULE module) {
 
   // Parse configuration from the command line and resources.
   Configuration configuration;
-  if (!configuration.Initialize()) {
+  if (!configuration.Initialize(module)) {
     return ProcessExitResult(GENERIC_INITIALIZATION_FAILURE, ::GetLastError());
   }
 
@@ -730,14 +873,41 @@ ProcessExitResult WMain(HMODULE module) {
     return exit_code;
   }
 
+#if BUILDFLAG(GOOGLE_CHROME_BRANDING)
+  // Set the magic suffix in registry to try full installer next time. We ignore
+  // any errors here and we try to set the suffix for user level unless
+  // GoogleUpdateIsMachine=1 is present in the environment or --system-level is
+  // on the command line in which case we set it for system level instead. This
+  // only applies to the Google Chrome distribution.
+  SetInstallerFlags(configuration);
+#endif
+
   int max_delete_attempts = 0;
   PathString setup_path;
+  ResourceTypeString setup_type;
   PathString archive_path;
   ResourceTypeString archive_type;
 
   exit_code =
-      UnpackBinaryResources(module, base_path.get(), setup_path, archive_path,
-                            archive_type, max_delete_attempts);
+      UnpackBinaryResources(module, base_path.get(), setup_path, setup_type,
+                            archive_path, archive_type, max_delete_attempts);
+
+  // If a compressed setup patch was found, run the previous setup.exe to
+  // patch and generate the new setup.exe.
+  if (exit_code.IsSuccess() && setup_type.compare(kLZMAResourceType) == 0) {
+    PathString setup_dest_path;
+    if (!setup_dest_path.assign(base_path.get()) ||
+        !setup_dest_path.append(kSetupExe)) {
+      return ProcessExitResult(PATH_STRING_OVERFLOW);
+    }
+    exit_code = PatchSetup(configuration, setup_path, setup_dest_path,
+                           max_delete_attempts);
+    if (exit_code.IsSuccess()) {
+      setup_path.assign(setup_dest_path);
+    } else {
+      setup_path.clear();
+    }
+  }
 
   // While unpacking the binaries, we paged in a whole bunch of memory that
   // we don't need anymore.  Let's give it back to the pool before running
