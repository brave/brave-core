diff --git a/components/sync_device_info/device_info_sync_bridge.cc b/components/sync_device_info/device_info_sync_bridge.cc
index f45d674c64a2f18e6589d785304c3a194e30ed33..3315da423cf8c21187d56e917bb3b20434d877e9 100644
--- a/components/sync_device_info/device_info_sync_bridge.cc
+++ b/components/sync_device_info/device_info_sync_bridge.cc
@@ -286,6 +286,7 @@ std::unique_ptr<DeviceInfoSpecifics> MakeLocalDeviceSpecifics(
         GetSpecificsFieldNumberFromDataType(data_type));
   }
 
+  BRAVE_MAKE_LOCAL_DEVICE_SPECIFICS
   return specifics;
 }
 
@@ -471,6 +472,7 @@ std::optional<ModelError> DeviceInfoSyncBridge::ApplyIncrementalSyncChanges(
   for (const std::unique_ptr<EntityChange>& change : entity_changes) {
     const std::string guid = change->storage_key();
 
+    BRAVE_DEVICE_INFO_SYNC_BRIDGE_APPLY_SYNC_CHANGES_SKIP_NEXT_IF
     // Reupload local device if it was deleted from the server.
     if (local_cache_guid_ == guid &&
         change->type() == EntityChange::ACTION_DELETE) {
@@ -481,7 +483,7 @@ std::optional<ModelError> DeviceInfoSyncBridge::ApplyIncrementalSyncChanges(
     // Ignore any remote changes that have a cache guid that is or was this
     // local device.
     if (device_info_prefs_->IsRecentLocalCacheGuid(guid)) {
-      continue;
+      if (change->type() != EntityChange::ACTION_DELETE) continue;
     }
 
     if (change->type() == EntityChange::ACTION_DELETE) {
@@ -832,6 +834,7 @@ void DeviceInfoSyncBridge::OnReadAllMetadata(
     return;
   }
 
+  BRAVE_ON_READ_ALL_METADATA_CLEAR_PROGRESS_TOKEN
   // In the regular case for sync being disabled, wait for MergeFullSyncData()
   // before initializing the LocalDeviceInfoProvider.
   if (!syncer::IsInitialSyncDone(
@@ -1062,6 +1065,7 @@ void DeviceInfoSyncBridge::ExpireOldEntries() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   CHECK(store_);
   TRACE_EVENT0("sync", "DeviceInfoSyncBridge::ExpireOldEntries");
+  BRAVE_SKIP_EXPIRE_OLD_ENTRIES
   const base::Time expiration_threshold =
       base::Time::Now() - kExpirationThreshold;
   std::unordered_set<std::string> cache_guids_to_expire;
