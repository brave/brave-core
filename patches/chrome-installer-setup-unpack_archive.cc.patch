diff --git a/chrome/installer/setup/unpack_archive.cc b/chrome/installer/setup/unpack_archive.cc
index 564547f24ef30a7b73ce59efdcfcf0bfd5842ef3..1f4f4f77b3c721668465d3970a6bf31cc958d53c 100644
--- a/chrome/installer/setup/unpack_archive.cc
+++ b/chrome/installer/setup/unpack_archive.cc
@@ -7,6 +7,8 @@
 
 #include "chrome/installer/setup/unpack_archive.h"
 
+#include <memory>
+
 #include "base/check.h"
 #include "base/check_op.h"
 #include "base/command_line.h"
@@ -16,6 +18,7 @@
 #include "base/types/expected.h"
 #include "base/types/expected_macros.h"
 #include "base/version.h"
+#include "chrome/installer/setup/archive_patch_helper.h"
 #include "chrome/installer/setup/installer_state.h"
 #include "chrome/installer/setup/setup_constants.h"
 #include "chrome/installer/setup/setup_util.h"
@@ -27,15 +30,59 @@ namespace installer {
 
 namespace {
 
-// Workhorse for producing an uncompressed archive (chrome.7z) given a
-// chrome.packed.7z containing the full uncompressed archive. Returns the path
-// to the uncompressed archive, or an error. In the error case, the result is
-// wrriten to registry (via WriteInstallerResult).
-base::expected<base::FilePath, InstallStatus> UncompressChromeArchive(
-    const base::FilePath& compressed_archive,
+// Returns nullptr if no compressed archive is available for processing,
+// otherwise returns a patch helper configured to uncompress and patch.
+std::unique_ptr<ArchivePatchHelper> CreateChromeArchiveHelper(
+    const base::FilePath& setup_exe,
+    const base::FilePath& install_archive,
+    const InstallerState& installer_state,
     const base::FilePath& working_directory,
-    const InstallerState& installer_state) {
+    UnPackConsumer consumer) {
+  // A compressed archive is ordinarily given on the command line by the mini
+  // installer. If one was not given, look for chrome.packed.7z next to the
+  // running program.
+  base::FilePath compressed_archive =
+      install_archive.empty()
+          ? setup_exe.DirName().Append(kChromeCompressedArchive)
+          : install_archive;
+
+  // Fail if no compressed archive is found.
+  if (!base::PathExists(compressed_archive)) {
+    LOG_IF(ERROR, !install_archive.empty())
+        << switches::kInstallArchive << "=" << compressed_archive.value()
+        << " not found.";
+    return nullptr;
+  }
+
+  // chrome.7z is either extracted directly from the compressed archive into the
+  // working dir or is the target of patching in the working dir.
+  base::FilePath target(working_directory.Append(kChromeArchive));
+  DCHECK(!base::PathExists(target));
+
+  // Specify an empty path for the patch source since it isn't yet known that
+  // one is needed. It will be supplied in UncompressAndPatchChromeArchive if it
+  // is.
+  return std::make_unique<ArchivePatchHelper>(
+      working_directory, compressed_archive, base::FilePath(), target,
+      consumer);
+}
+
+}  // namespace
+
+// Workhorse for producing an uncompressed archive (chrome.7z) given a
+// chrome.packed.7z containing either a patch file based on the version of
+// chrome being updated or the full uncompressed archive. Returns true on
+// success, in which case |archive_type| is populated based on what was found.
+// Returns false on failure, in which case |install_status| contains the error
+// code and the result is written to the registry (via WriteInstallerResult).
+base::expected<void, InstallStatus> UncompressAndPatchChromeArchive(
+    const InstallationState& original_state,
+    const InstallerState& installer_state,
+    ArchivePatchHelper* archive_helper,
+    ArchiveType* archive_type,
+    const base::Version& previous_version) {
   installer_state.SetStage(UNCOMPRESSING);
+
   // UMA tells us the following about the time required for uncompression as of
   // M75:
   // --- Foreground (<10%) ---
@@ -63,32 +110,63 @@ base::expected<base::FilePath, InstallStatus> UncompressChromeArchive(
   // More information can also be found with metrics:
   // Setup.Install.LzmaUnPackNTSTATUS_CompressedChromeArchive
   // Setup.Install.LzmaUnPackNTSTATUS_ChromeArchivePatch
-  base::FilePath output_file;
-  UnPackStatus unpack_status =
-      UnPackArchive(compressed_archive, working_directory, &output_file);
-  RecordUnPackMetrics(unpack_status, UnPackConsumer::COMPRESSED_CHROME_ARCHIVE);
-  if (unpack_status != UNPACK_NO_ERROR) {
+  if (!archive_helper->Uncompress(nullptr)) {
     installer_state.WriteInstallerResult(
         UNCOMPRESSION_FAILED, IDS_INSTALL_UNCOMPRESSION_FAILED_BASE, nullptr);
     return base::unexpected(UNCOMPRESSION_FAILED);
   }
-  return base::ok(output_file);
-}
 
-}  // namespace
+  // Short-circuit if uncompression produced the uncompressed archive rather
+  // than a patch file.
+  if (base::PathExists(archive_helper->target())) {
+    *archive_type = FULL_ARCHIVE_TYPE;
+    return base::ok();
+  }
+
+  // Find the installed version's archive to serve as the source for patching.
+  base::FilePath patch_source(
+      FindArchiveToPatch(original_state, installer_state, previous_version));
+  if (patch_source.empty()) {
+    LOG(ERROR) << "Failed to find archive to patch.";
+    installer_state.WriteInstallerResult(DIFF_PATCH_SOURCE_MISSING,
+                                         IDS_INSTALL_UNCOMPRESSION_FAILED_BASE,
+                                         nullptr);
+    return base::unexpected(DIFF_PATCH_SOURCE_MISSING);
+  }
+  archive_helper->set_patch_source(patch_source);
+
+  // UMA tells us the following about the time required for patching as of M75:
+  // --- Foreground ---
+  //   12s (50%ile) / 3-6m (99%ile)
+  // --- Background ---
+  //   1m (50%ile) / >60m (99%ile)
+  installer_state.SetStage(PATCHING);
+  if (!archive_helper->ApplyAndDeletePatch()) {
+    installer_state.WriteInstallerResult(APPLY_DIFF_PATCH_FAILED,
+                                         IDS_INSTALL_UNCOMPRESSION_FAILED_BASE,
+                                         nullptr);
+    return base::unexpected(APPLY_DIFF_PATCH_FAILED);
+  }
+
+  *archive_type = INCREMENTAL_ARCHIVE_TYPE;
+  return base::ok();
+}
 
-base::expected<base::FilePath, InstallStatus> UnpackChromeArchive(
+base::expected<void, InstallStatus> UnpackAndMaybePatchChromeArchive(
     const base::FilePath& unpack_path,
     InstallationState& original_state,
     const base::FilePath& setup_exe,
     const base::CommandLine& cmd_line,
-    const InstallerState& installer_state) {
+    const InstallerState& installer_state,
+    ArchiveType* archive_type,
+    base::FilePath& uncompressed_archive) {
+  *archive_type = UNKNOWN_ARCHIVE_TYPE;
   base::FilePath install_archive =
       cmd_line.GetSwitchValuePath(switches::kInstallArchive);
   // If this is an uncompressed installation then pass the uncompressed
   // chrome.7z directly, so the chrome.packed.7z unpacking step will be
   // bypassed.
-  base::FilePath uncompressed_archive =
+  uncompressed_archive =
       cmd_line.GetSwitchValuePath(switches::kUncompressedArchive);
   if (!install_archive.empty() || uncompressed_archive.empty()) {
     if (!uncompressed_archive.empty()) {
@@ -97,26 +175,26 @@ base::expected<base::FilePath, InstallStatus> UnpackChromeArchive(
              "provided. This is unsupported. Please provide one archive.";
       return base::unexpected(UNSUPPORTED_OPTION);
     }
+    base::Version previous_version;
+    if (cmd_line.HasSwitch(switches::kPreviousVersion)) {
+      previous_version = base::Version(
+          cmd_line.GetSwitchValueASCII(switches::kPreviousVersion));
+    }
 
-    // A compressed archive is ordinarily given on the command line by the mini
-    // installer. If one was not given, look for chrome.packed.7z next to the
-    // running program.
-    base::FilePath compressed_archive =
-        install_archive.empty()
-            ? setup_exe.DirName().Append(kChromeCompressedArchive)
-            : install_archive;
-
-    // Uncompress if a compressed archive exists.
-    if (base::PathExists(compressed_archive)) {
+    std::unique_ptr<ArchivePatchHelper> archive_helper(
+        CreateChromeArchiveHelper(
+            setup_exe, install_archive, installer_state, unpack_path,
+            (previous_version.IsValid()
+                 ? UnPackConsumer::CHROME_ARCHIVE_PATCH
+                 : UnPackConsumer::COMPRESSED_CHROME_ARCHIVE)));
+    if (archive_helper) {
       VLOG(1) << "Installing Chrome from compressed archive "
-              << compressed_archive;
-      ASSIGN_OR_RETURN(uncompressed_archive,
-                       UncompressChromeArchive(compressed_archive, unpack_path,
-                                               installer_state));
-    } else {
-      LOG_IF(ERROR, !install_archive.empty())
-          << switches::kInstallArchive << "=" << compressed_archive
-          << " not found.";
+              << archive_helper->compressed_archive().value();
+      RETURN_IF_ERROR(UncompressAndPatchChromeArchive(
+          original_state, installer_state, archive_helper.get(), archive_type,
+          previous_version));
+      uncompressed_archive = archive_helper->target();
+      DCHECK(!uncompressed_archive.empty());
     }
   }
 
@@ -124,12 +202,18 @@ base::expected<base::FilePath, InstallStatus> UnpackChromeArchive(
   // was not given or generated.
   if (uncompressed_archive.empty()) {
     uncompressed_archive = setup_exe.DirName().Append(kChromeArchive);
-    if (base::PathExists(uncompressed_archive)) {
+  }
+
+  if (*archive_type == UNKNOWN_ARCHIVE_TYPE) {
+    // An archive was not uncompressed or patched above.
+    if (uncompressed_archive.empty() ||
+        !base::PathExists(uncompressed_archive)) {
       LOG(ERROR) << "Cannot install Chrome without an uncompressed archive.";
       installer_state.WriteInstallerResult(
           INVALID_ARCHIVE, IDS_INSTALL_INVALID_ARCHIVE_BASE, nullptr);
       return base::unexpected(INVALID_ARCHIVE);
     }
+    *archive_type = FULL_ARCHIVE_TYPE;
   }
 
   // Unpack the uncompressed archive.
@@ -160,7 +244,7 @@ base::expected<base::FilePath, InstallStatus> UnpackChromeArchive(
         UNPACKING_FAILED, IDS_INSTALL_UNCOMPRESSION_FAILED_BASE, nullptr);
     return base::unexpected(UNPACKING_FAILED);
   }
-  return base::ok(uncompressed_archive);
+  return base::ok();
 }
 
 }  // namespace installer
