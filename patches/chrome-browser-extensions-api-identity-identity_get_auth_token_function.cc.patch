diff --git a/chrome/browser/extensions/api/identity/identity_get_auth_token_function.cc b/chrome/browser/extensions/api/identity/identity_get_auth_token_function.cc
index 0ce56bdbb206bb0c685c256e38a2fd7b6db65be9..22aff5b2aca222a6d3c30075cf467869ddcaf7ae 100644
--- a/chrome/browser/extensions/api/identity/identity_get_auth_token_function.cc
+++ b/chrome/browser/extensions/api/identity/identity_get_auth_token_function.cc
@@ -210,6 +210,7 @@ ExtensionFunction::ResponseAction IdentityGetAuthTokenFunction::Run() {
   // From here on out, results must be returned asynchronously.
   StartAsyncRun();
 
+  BRAVE_RUN
   // TODO(crbug.com/40614113): collapse the asynchronicity
   base::OnceCallback next_step =
       base::BindOnce(&IdentityGetAuthTokenFunction::GetAuthTokenForAccount,
@@ -384,12 +385,14 @@ void IdentityGetAuthTokenFunction::StartSigninFlow() {
 void IdentityGetAuthTokenFunction::StartMintTokenFlow(
     IdentityMintRequestQueue::MintType type) {
 #if !BUILDFLAG(IS_CHROMEOS)
+  BRAVE_START_MINT_TOKEN_FLOW_IF
   // ChromeOS in kiosk mode may start the mint token flow without account.
   DCHECK(!token_key_.account_info.IsEmpty())
       << "token_key_.account_info is empty!";
   DCHECK(IdentityManagerFactory::GetForProfile(GetProfile())
              ->HasAccountWithRefreshToken(token_key_.account_info.account_id))
       << "No Refresh token!";
+  BRAVE_START_MINT_TOKEN_FLOW_ELSE
 #endif
   TRACE_EVENT_BEGIN("identity", "MintTokenFlow",
                     perfetto::Track::FromPointer(this), "type", type);
