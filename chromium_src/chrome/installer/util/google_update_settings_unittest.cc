/* Copyright (c) 2025 The Brave Authors. All rights reserved.
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at https://mozilla.org/MPL/2.0/. */

// This file contains tests that used to be upstream and had to be restored in
// Brave to support delta updates on Windows until we are on Omaha 4. See:
// github.com/brave/brave-core/pull/31937

#ifdef UNSAFE_BUFFERS_BUILD
// TODO(https://github.com/brave/brave-browser/issues/50977): Remove this and
// convert code to safer constructs.
#pragma allow_unsafe_buffers
#endif

#include "chrome/installer/util/google_update_settings.h"

#include "brave/installer/chromium_index_helper_begin.h"
#define UpdateGoogleUpdateApKey UpdateGoogleUpdateApKey_Unused
#define UpdateInstallStatus UpdateInstallStatus_Unused
#include <chrome/installer/util/google_update_settings_unittest.cc>
#undef UpdateInstallStatus
#undef UpdateGoogleUpdateApKey
#include "brave/installer/chromium_index_helper_end.h"

// Run through all combinations of diff vs. full install, success and failure
// results, and a fistful of initial "ap" values checking that the expected
// final "ap" value is generated by
// GoogleUpdateSettings::UpdateGoogleUpdateApKey.
TEST_F(GoogleUpdateSettingsTest, UpdateGoogleUpdateApKey) {
  const installer::ArchiveType archive_types[] = {
      installer::UNKNOWN_ARCHIVE_TYPE, installer::FULL_ARCHIVE_TYPE,
      installer::INCREMENTAL_ARCHIVE_TYPE};
  const int results[] = {installer::FIRST_INSTALL_SUCCESS,
                         installer::INSTALL_FAILED};
  const wchar_t* const plain[] = {L"", L"1.1", L"1.1-dev"};
  const wchar_t* const full[] = {L"-full", L"1.1-full", L"1.1-dev-full"};
  static_assert(std::size(full) == std::size(plain), "bad full array size");
  const wchar_t* const* input_arrays[] = {plain, full};
  for (const installer::ArchiveType archive_type : archive_types) {
    SCOPED_TRACE(::testing::Message()
                 << "archive_type="
                 << (archive_type == installer::UNKNOWN_ARCHIVE_TYPE
                         ? "UNKNOWN"
                         : (archive_type == installer::FULL_ARCHIVE_TYPE
                                ? "FULL"
                                : "INCREMENTAL")));
    for (const int result : results) {
      SCOPED_TRACE(::testing::Message()
                   << "result="
                   << (result == installer::FIRST_INSTALL_SUCCESS ? "SUCCESS"
                                                                  : "FAILED"));
      // The archive type will/must always be known on install success.
      if (archive_type == installer::UNKNOWN_ARCHIVE_TYPE &&
          result == installer::FIRST_INSTALL_SUCCESS) {
        continue;
      }
      const wchar_t* const* outputs = nullptr;
      if (result == installer::FIRST_INSTALL_SUCCESS ||
          archive_type == installer::FULL_ARCHIVE_TYPE) {
        outputs = plain;
      } else if (archive_type == installer::INCREMENTAL_ARCHIVE_TYPE) {
        outputs = full;
      }  // else if (archive_type == UNKNOWN) see below

      for (const wchar_t* const* inputs : input_arrays) {
        if (archive_type == installer::UNKNOWN_ARCHIVE_TYPE) {
          // "-full" is untouched if the archive type is unknown.
          if (inputs == full) {
            outputs = full;
          } else {
            outputs = plain;
          }
        }
        for (size_t input_idx = 0; input_idx < std::size(plain); ++input_idx) {
          const wchar_t* input = inputs[input_idx];
          const wchar_t* output = outputs[input_idx];
          SCOPED_TRACE(::testing::Message() << "input=\"" << input << "\"");
          SCOPED_TRACE(::testing::Message() << "output=\"" << output << "\"");

          std::unique_ptr<WorkItemList> work_item_list(
              WorkItem::CreateWorkItemList());

          ASSERT_TRUE(CreateApKey(work_item_list.get(), input));
          installer::AdditionalParameters ap;
          if (std::wstring_view(output) == ap.value()) {
            EXPECT_FALSE(GoogleUpdateSettings::UpdateGoogleUpdateApKey(
                archive_type, result, &ap));
          } else {
            EXPECT_TRUE(GoogleUpdateSettings::UpdateGoogleUpdateApKey(
                archive_type, result, &ap));
          }
          EXPECT_STREQ(output, ap.value());
        }
      }
    }
  }
}

TEST_F(GoogleUpdateSettingsTest, UpdateInstallStatusTestIncremental) {
  std::unique_ptr<WorkItemList> work_item_list(WorkItem::CreateWorkItemList());
  // Test incremental install failure
  ASSERT_TRUE(CreateApKey(work_item_list.get(), L""))
      << "Failed to create ap key.";
  GoogleUpdateSettings::UpdateInstallStatus(
      false, installer::INCREMENTAL_ARCHIVE_TYPE, installer::INSTALL_FAILED);
  EXPECT_STREQ(ReadApKeyValue().c_str(), L"-full");
  work_item_list->Rollback();

  work_item_list.reset(WorkItem::CreateWorkItemList());
  // Test incremental install success
  ASSERT_TRUE(CreateApKey(work_item_list.get(), L""))
      << "Failed to create ap key.";
  GoogleUpdateSettings::UpdateInstallStatus(false,
                                            installer::INCREMENTAL_ARCHIVE_TYPE,
                                            installer::FIRST_INSTALL_SUCCESS);
  EXPECT_STREQ(ReadApKeyValue().c_str(), L"");
  work_item_list->Rollback();

  work_item_list.reset(WorkItem::CreateWorkItemList());
  // Test full install failure
  ASSERT_TRUE(CreateApKey(work_item_list.get(), L"-full"))
      << "Failed to create ap key.";
  GoogleUpdateSettings::UpdateInstallStatus(false, installer::FULL_ARCHIVE_TYPE,
                                            installer::INSTALL_FAILED);
  EXPECT_STREQ(ReadApKeyValue().c_str(), L"");
  work_item_list->Rollback();

  work_item_list.reset(WorkItem::CreateWorkItemList());
  // Test full install success
  ASSERT_TRUE(CreateApKey(work_item_list.get(), L"-full"))
      << "Failed to create ap key.";
  GoogleUpdateSettings::UpdateInstallStatus(false, installer::FULL_ARCHIVE_TYPE,
                                            installer::FIRST_INSTALL_SUCCESS);
  EXPECT_STREQ(ReadApKeyValue().c_str(), L"");
  work_item_list->Rollback();

  work_item_list.reset(WorkItem::CreateWorkItemList());
  // Test the case of when "ap" key doesnt exist at all
  std::wstring ap_key_value = ReadApKeyValue();
  std::wstring reg_key = GetApKeyPath();
  HKEY reg_root = HKEY_CURRENT_USER;
  bool ap_key_deleted = false;
  RegKey key;
  if (key.Open(HKEY_CURRENT_USER, reg_key.c_str(),
               KEY_WOW64_32KEY | KEY_SET_VALUE) != ERROR_SUCCESS) {
    work_item_list->AddCreateRegKeyWorkItem(reg_root, reg_key, KEY_WOW64_32KEY);
    ASSERT_TRUE(work_item_list->Do()) << "Failed to create ClientState key.";
  } else if (key.DeleteValue(google_update::kRegApField) == ERROR_SUCCESS) {
    ap_key_deleted = true;
  }
  // try differential installer
  GoogleUpdateSettings::UpdateInstallStatus(
      false, installer::INCREMENTAL_ARCHIVE_TYPE, installer::INSTALL_FAILED);
  EXPECT_STREQ(ReadApKeyValue().c_str(), L"-full");
  // try full installer now
  GoogleUpdateSettings::UpdateInstallStatus(false, installer::FULL_ARCHIVE_TYPE,
                                            installer::INSTALL_FAILED);
  EXPECT_STREQ(ReadApKeyValue().c_str(), L"");
  // Now cleanup to leave the system in unchanged state.
  // - Diff installer creates an ap key if it didn't exist, so delete this ap
  // key
  // - If we created any reg key path for ap, roll it back
  // - Finally restore the original value of ap key.
  if (key.Open(HKEY_CURRENT_USER, reg_key.c_str(),
               KEY_WOW64_32KEY | KEY_SET_VALUE) == ERROR_SUCCESS) {
    key.DeleteValue(google_update::kRegApField);
  }
  work_item_list->Rollback();
  if (ap_key_deleted) {
    work_item_list.reset(WorkItem::CreateWorkItemList());
    ASSERT_TRUE(CreateApKey(work_item_list.get(), ap_key_value))
        << "Failed to restore ap key.";
  }
}
