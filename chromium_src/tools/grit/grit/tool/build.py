# Copyright (c) 2025 The Brave Authors. All rights reserved.
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this file,
# You can obtain one at https://mozilla.org/MPL/2.0/.

from collections import defaultdict
import json

from override_utils import override_function, override_method

from grit.node import message


def _GetMessageText(msg_or_ph):
    """Get the content of a <message> or <ph> node. This is the text used in
       as the mock content and is English text of the message
       (excluding examples)."""
    result = ''
    for child in msg_or_ph.mixed_content:
        if isinstance(child, message.PhNode):
            result += _GetMessageText(child)
        elif isinstance(child, str):
            result += child

    return result

def _GetWebuiMessageAndIds(root):
    """Collects webui messages grouped by their webui attribute value."""

    IDS_PREFIX_LEN = 4

    ids_map = root.GetIdMap()
    grouped_messages = defaultdict(list)

    for item in root.ActiveDescendants():
        if not isinstance(item, message.MessageNode):
            continue

        webui = item.formatter_data.get('webui')
        if not webui:
            continue

        name = item.attrs['name']
        # Strip 'IDS_' prefix from message names.
        grouped_messages[webui].append(
            (name[IDS_PREFIX_LEN:], ids_map[name], _GetMessageText(item)))

    return grouped_messages


def _FormatWebuiHeader(root, *_args, **_kwargs):
    """Generates C++ header with webui::LocalizedString arrays for each group."""

    yield ('// This file is automatically generated by GRIT. Do not edit.\n\n'
           '#pragma once\n\n'
           '#include <array>\n\n')

    if root.IsAllowlistSupportEnabled():
        yield '#include "ui/base/resource/allowlist.h"\n'
    yield '#include "ui/base/webui/web_ui_util.h"\n\n'

    yield 'namespace webui {\n'

    for group, messages in _GetWebuiMessageAndIds(root).items():
        # Create constexpr array of LocalizedString structs.
        yield (f'\ninline constexpr auto k{group}Strings = '
               'std::to_array<LocalizedString>({\n')

        for name, ids_value, _ in messages:
            if root.IsAllowlistSupportEnabled():
                yield f'    {{"{name}", (::ui::AllowlistedResource<{ids_value}>(), {ids_value})}},\n'
            else:
                yield f'    {{"{name}", {ids_value}}},\n'

        yield '});\n'

    yield '\n}  // namespace webui\n'


def _FormatWebuiMock(root, *_args, **_kwargs):
    """Generates a Typescript file with the strings for mock usage (ie. for
       Storybook or tests)."""

    yield '// This file is automatically generated by GRIT. Do not edit.\n\n'

    yield 'export default {\n'

    for _, messages in _GetWebuiMessageAndIds(root).items():
        for name, _, text in messages:
            yield f"  {name}: {json.dumps(text, ensure_ascii=False)},\n"

    yield '}\n'


def _FormatWebuiTs(root, *_args, **_kwargs):
    """Generates TypeScript enums with string constants for webui usage."""

    yield '// This file is automatically generated by GRIT. Do not edit.\n'

    for group, messages in _GetWebuiMessageAndIds(root).items():
        yield f'\nexport const enum {group}Strings {{\n'

        for name, _, _ in messages:
            # Enum values are the same as their keys and IDS_ for easy grepping.
            yield f'  {name} = "{name}",\n'

        yield '}\n'


_CUSTOM_FORMATTERS = {
    'webui_header': _FormatWebuiHeader,
    'webui_mock': _FormatWebuiMock,
    'webui_ts': _FormatWebuiTs,
}


@override_function(globals())
def GetFormatter(original_function, formatter_type):
    """Add support for additional formats."""
    if formatter := _CUSTOM_FORMATTERS.get(formatter_type):
        return formatter

    return original_function(formatter_type)


@override_method(RcBuilder)
def _EncodingForOutputType(_, original_method, output_type):
    """We need to override the encoding for our formats to be utf_8, as grit
       outputs utf_16 by default.
    """
    if output_type in _CUSTOM_FORMATTERS:
        return 'utf_8'

    return original_method(output_type)
