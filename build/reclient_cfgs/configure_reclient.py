#!/usr/bin/env python3
# Copyright (c) 2023 The Brave Authors. All rights reserved.
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this file,
# You can obtain one at https://mozilla.org/MPL/2.0/.

import glob
import os
import re
import shutil
import string
import subprocess
import sys

SCRIPT_DIR = os.path.dirname(__file__).replace('\\', '/')
SRC_DIR = os.path.abspath(f'{SCRIPT_DIR}/../../..').replace('\\', '/')
EXEC_ROOT = os.path.abspath(f'{SRC_DIR}/..').replace('\\', '/')

BUILD_DIR = f'{SRC_DIR}/out/a'  # Used to generate relative paths.
RECLIENT_CFGS_DIR = f'{SRC_DIR}/buildtools/reclient_cfgs'
CLANG_DIR = f'{SRC_DIR}/third_party/llvm-build/Release+Asserts'
LINUX_CLANG_DIR = f'{SRC_DIR}/third_party/llvm-build/Release+Asserts_linux'

GENERATED_FILE_HEADER = '''# AUTOGENERATED FILE - DO NOT EDIT
# Generated by:
{source_script}
#
# To edit update:
{source_files}
# And run 'npm run sync'.
'''


class ShellTemplate(string.Template):
    delimiter = '%'


def main():
    if not os.environ.get('RBE_service'):
        # Do nothing if RBE environment is not configured.
        return

    # Reproxy config includes auth, and network-related parameters.
    generate_reproxy_cfg()
    # Rewrapper configs describe how different tools should be run remotely.
    generate_rewrapper_cfgs()
    # Python remote wrapper sets environment variables during remote execution.
    generate_python_remote_wrapper()

    if not sys.platform.startswith('linux'):
        # Linux clang toolchain and clang remote wrapper are required on
        # non-linux hosts to perform cross-compilation remotely.
        download_linux_clang_toolchain()
        generate_clang_remote_wrapper()


def generate_reproxy_cfg():
    # Set Chromium config template variables to empty values.
    CHROMIUM_TEMPLATE_MAPPINGS = {
        'auth_flags': '',
        'depsscanner_address': '',
        'rbe_instance': '',
        'rbe_project': '',
    }
    # Load Chromium config template.
    reproxy_cfg = parse_reclient_cfg(
        string.Template(
            read_text_file(
                f'{RECLIENT_CFGS_DIR}/reproxy_cfg_templates/'
                'reproxy.cfg.template')).substitute(CHROMIUM_TEMPLATE_MAPPINGS))
    # Merge with our config.
    source_cfg_path = f'{SCRIPT_DIR}/reproxy.cfg'
    reproxy_cfg = merge_reclient_cfg(source_cfg_path, reproxy_cfg)

    # Use scandeps_server.
    depsscanner_address = (f'exec://{SRC_DIR}/'
                           'buildtools/reclient/scandeps_server')
    if sys.platform.startswith('win'):
        depsscanner_address += '.exe'
    reproxy_cfg['depsscanner_address'] = depsscanner_address

    # Set values from supoprted RBE_ environment variables.
    SUPPORTED_REPROXY_ENV_VARS = (
        'RBE_service',
        'RBE_service_no_auth',
        'RBE_tls_client_auth_cert',
        'RBE_tls_client_auth_key',
        'RBE_use_application_default_credentials',
    )
    for env_var in SUPPORTED_REPROXY_ENV_VARS:
        value = os.environ.get(env_var)
        if value:
            key = env_var[4:]
            reproxy_cfg[key] = from_reclient_cfg_value(key, value)

    # Write the final config to the expected location.
    write_reclient_cfg(f'{RECLIENT_CFGS_DIR}/reproxy.cfg', reproxy_cfg,
                       source_cfg_path)


def generate_rewrapper_cfgs():
    # Generate chromium-browser-clang configs.
    generate_rewrapper_cfg('chromium-browser-clang', 'rewrapper_linux.cfg')
    generate_rewrapper_cfg('chromium-browser-clang', 'rewrapper_mac.cfg')
    generate_rewrapper_cfg('chromium-browser-clang', 'rewrapper_windows.cfg')

    # Generate python configs.
    generate_rewrapper_cfg('python', 'rewrapper_linux.cfg')
    generate_rewrapper_cfg('python', 'rewrapper_mac.cfg')
    generate_rewrapper_cfg('python', 'rewrapper_windows.cfg')


def generate_rewrapper_cfg(tool_dir, cfg):
    # Load Chromium config for linux remote.
    rewrapper_cfg = read_reclient_cfg(f'{RECLIENT_CFGS_DIR}/linux/{tool_dir}/'
                                      'rewrapper_linux.cfg')
    # Merge with our configs (rewrapper_base and rewrapper_<host>).
    source_cfg_paths = (
        f'{SCRIPT_DIR}/{tool_dir}/rewrapper_base.cfg',
        f'{SCRIPT_DIR}/{tool_dir}/{cfg}',
    )
    for source_cfg_path in source_cfg_paths:
        rewrapper_cfg = merge_reclient_cfg(source_cfg_path, rewrapper_cfg)
    # Write the final config to the expected location.
    write_reclient_cfg(f'{RECLIENT_CFGS_DIR}/{tool_dir}/{cfg}', rewrapper_cfg,
                       source_cfg_paths)


def generate_python_remote_wrapper():
    # Load python remote wrapper template.
    source_file = f'{SCRIPT_DIR}/python/python_remote_wrapper.template'
    python_remote_wrapper_template = read_text_file(source_file)

    # Generate PYTHONPATH env variable with paths accessible from EXEC_ROOT.
    relative_python_paths = []
    for python_path in os.environ.get('PYTHONPATH', '').split(os.pathsep):
        if not python_path:
            continue
        abs_python_path = os.path.abspath(python_path).replace('\\', '/')
        if abs_python_path.startswith(EXEC_ROOT):
            relative_python_paths.append(relpath(abs_python_path, BUILD_DIR))

    # Variables to replace in the template.
    template_vars = {
        'AUTOGENERATED_HEADER': create_generated_header(source_file),
        'PYTHONPATH': ':'.join(relative_python_paths),
    }

    if not template_vars['PYTHONPATH']:
        print('WARNING: PYTHONPATH is empty. Remote python actions will fail.')

    # Write the python remote wrapper.
    write_text_file(
        f'{SRC_DIR}/buildtools/reclient_cfgs/python/python_remote_wrapper',
        ShellTemplate(python_remote_wrapper_template).substitute(template_vars))


def download_linux_clang_toolchain():
    subprocess.check_call([
        'python3',
        f'{SRC_DIR}/tools/clang/scripts/update.py',
        '--output-dir',
        f'{LINUX_CLANG_DIR}',
        '--host-os',
        'linux',
    ])


def generate_clang_remote_wrapper():
    if not os.path.exists(CLANG_DIR):
        raise RuntimeError(f'Cannot find clang directory at {CLANG_DIR}.')

    # Load clang remote wrapper template.
    source_file = (f'{SCRIPT_DIR}/chromium-browser-clang/'
                   'clang_remote_wrapper.template')
    clang_remote_wrapper_template = read_text_file(source_file)

    # Find "include" directory inside clang installation. This directory will be
    # symlinked by remote wrapper for cross-compilation to work. The path is
    # clang-version dependent, so don't hardcode it.
    clang_include_dir_glob = glob.glob(f'{CLANG_DIR}/lib/**/include',
                                       recursive=True)
    if not clang_include_dir_glob:
        raise RuntimeError(
            f'Cannot find lib/**/include dir in {CLANG_DIR}. If clang '
            f'structure has changed, please update {__file__}.')
    clang_include_dir_abs = clang_include_dir_glob[0].replace('\\', '/')
    assert os.path.isdir(clang_include_dir_abs), clang_include_dir_abs
    clang_include_dir = relpath(clang_include_dir_abs, BUILD_DIR)
    linux_clang_include_dir = relpath(
        clang_include_dir_abs.replace(CLANG_DIR, LINUX_CLANG_DIR), BUILD_DIR)

    # Variables to replace in the template.
    template_vars = {
        'AUTOGENERATED_HEADER': create_generated_header(source_file),
        'CLANG_DIR': relpath(CLANG_DIR, BUILD_DIR),
        'CLANG_INCLUDE_DIR': clang_include_dir,
        'LINUX_CLANG_DIR': relpath(LINUX_CLANG_DIR, BUILD_DIR),
        'LINUX_CLANG_INCLUDE_DIR': linux_clang_include_dir,
    }

    # Write the clang remote wrapper.
    write_text_file(
        (f'{SRC_DIR}/buildtools/reclient_cfgs/chromium-browser-clang/'
         'clang_remote_wrapper'),
        ShellTemplate(clang_remote_wrapper_template).substitute(template_vars))


### Reclient config manipulation helpers. ###
def read_reclient_cfg(cfg_path):
    return dict(read_reclient_cfg_items(cfg_path))


def read_reclient_cfg_items(cfg_path):
    with open(cfg_path, 'r') as f:
        yield from parse_reclient_cfg_items(f)


def parse_reclient_cfg(cfg_string):
    return dict(parse_reclient_cfg_items(cfg_string.split('\n')))


def parse_reclient_cfg_items(lines):
    for line in lines:
        line = line.strip()
        if not re.match(r'^\w+=', line):
            continue
        key, value = line.split('=', 1)
        yield key, from_reclient_cfg_value(key, value)


def write_reclient_cfg(cfg_path, cfg, source_cfg_paths):
    cfg_to_write = create_generated_header(source_cfg_paths) + '\n'
    for key, value in cfg.items():
        formatted_value = to_reclient_cfg_value(key, value)
        if formatted_value:
            cfg_to_write += f'{formatted_value}\n'

    write_text_file(cfg_path, cfg_to_write)


def from_reclient_cfg_value(key, value):
    KEY_VALUE_PARAMS = (
        'labels',
        'platform',
    )
    LIST_PARAMS = (
        'env_var_allowlist',
        'input_list_paths',
        'inputs',
        'output_files',
        'output_directories',
        'toolchain_inputs',
    )

    if key in KEY_VALUE_PARAMS:
        ret_val = {}
        for sub_kv in value.split(','):
            if not sub_kv:
                continue
            if '=' not in sub_kv:
                raise RuntimeError(f'key=value expected for key: {key}')
            sub_key, sub_value = sub_kv.split('=', 1)
            ret_val[sub_key] = sub_value
        return ret_val

    if key in LIST_PARAMS:
        if not value:
            return []
        return value.split(',')

    return value


def to_reclient_cfg_value(key, value):
    if isinstance(value, dict):
        sub_keys_values = []
        for sub_key, sub_value in value.items():
            sub_keys_values.append(to_reclient_cfg_value(sub_key, sub_value))
        return to_reclient_cfg_value(key, sub_keys_values)

    if isinstance(value, list):
        return to_reclient_cfg_value(key, ','.join(filter(lambda v: v, value)))

    return f'{key}={value}' if value else None


def merge_reclient_cfg(cfg_path, reclient_cfg):
    for key, value in read_reclient_cfg_items(cfg_path):
        reclient_cfg = merge_reclient_cfg_item(reclient_cfg, {key: value})
    return reclient_cfg


def merge_reclient_cfg_item(a, b):
    if isinstance(a, dict):
        assert isinstance(b, dict)
        if not b:
            a.clear()
        else:
            for key in b:
                if key in a:
                    a[key] = merge_reclient_cfg_item(a[key], b[key])
                else:
                    a[key] = b[key]
    elif isinstance(a, list):
        assert isinstance(b, list)
        if not b:
            a.clear()
        else:
            a.extend(b)
    else:
        a = b

    return a


### File helpers. ###
def read_text_file(filepath):
    with open(filepath, 'r') as f:
        return f.read()


def write_text_file(filepath, data_to_write):
    if os.path.isfile(filepath):
        with open(filepath, 'r') as f:
            if f.read() == data_to_write:
                return

    os.makedirs(os.path.dirname(filepath), exist_ok=True)

    filepath_new = filepath + '.new'
    with open(filepath_new, 'w', newline='\n') as f:
        f.write(data_to_write)

    shutil.move(filepath_new, filepath)


def create_generated_header(source_files):
    if not isinstance(source_files, (list, tuple)):
        source_files = (source_files, )
    source_script = f'# //{relpath(__file__, SRC_DIR)}'
    source_files = '\n'.join(
        [f'# //{relpath(f, SRC_DIR)}' for f in source_files])

    return GENERATED_FILE_HEADER.format(
        source_script=source_script,
        source_files=source_files,
    )


def relpath(a, b):
    return os.path.relpath(a, b).replace('\\', '/')


if __name__ == '__main__':
    main()
